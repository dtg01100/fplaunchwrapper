  #!/usr/bin/env python3
> """Wrapper management functionality for fplaunchwrapper
> Replaces fplaunch-manage bash script with Python implementation.
> """
  
> from __future__ import annotations
  
> import os
> import sys
> from pathlib import Path
  
> try:
>     from rich.console import Console
>     from rich.table import Table
  
>     RICH_AVAILABLE = True
! except ImportError:
!     RICH_AVAILABLE = False
  
  # Initialize Rich consoles for stdout and stderr
> console = Console() if RICH_AVAILABLE else None
> console_err = Console(stderr=True) if RICH_AVAILABLE else None
  
  # Import our utilities
> try:
>     from .python_utils import (
>         get_wrapper_id,
>         is_wrapper_file,
>     )
  
>     UTILS_AVAILABLE = True
! except ImportError:
!     UTILS_AVAILABLE = False
  
  
> class WrapperManager:
>     """Manages Flatpak application wrappers."""
  
>     def __init__(
>         self,
>         config_dir: str | None = None,
>         bin_dir: str | None = None,
>         verbose: bool = False,
>         emit_mode: bool = False,
>         emit_verbose: bool = False,
>     ) -> None:
          # Backwards compatibility: allow positional booleans for verbose/emit flags
>         if isinstance(bin_dir, bool):
!             verbose, emit_mode, emit_verbose = bin_dir, verbose, emit_mode
!             bin_dir = None
  
>         self.verbose = verbose
>         self.emit_mode = emit_mode
>         self.emit_verbose = emit_verbose
>         self.config_dir = Path(
>             config_dir or (Path.home() / ".config" / "fplaunchwrapper"),
>         )
  
          # Get bin directory - prioritize parameter, then config, then default
>         if bin_dir:
>             self.bin_dir = Path(bin_dir)
>         else:
>             bin_dir_file = self.config_dir / "bin_dir"
>             try:
>                 if bin_dir_file.exists():
>                     bin_dir_path = bin_dir_file.read_text().strip()
>                     if bin_dir_path:
>                         self.bin_dir = Path(bin_dir_path)
!                     else:
!                         self.bin_dir = Path.home() / "bin"
>                 else:
>                     self.bin_dir = Path.home() / "bin"
>             except (OSError, UnicodeDecodeError):
                  # If we can't read the config file for any reason, fall back to default
>                 self.bin_dir = Path.home() / "bin"
  
          # Ensure directories exist (unless in emit mode)
>         if not emit_mode:
>             self.bin_dir.mkdir(parents=True, exist_ok=True)
>             self.config_dir.mkdir(parents=True, exist_ok=True)
  
>     def log(self, message: str, level: str = "info") -> None:
>         """Log a message to stdout or stderr based on level.
  
>         Error and warning messages go to stderr.
>         Info and success messages go to stdout.
>         Always prints regardless of verbose mode.
>         """
>         if level == "error":
              # Errors always go to stderr
>             if console_err:
>                 console_err.print(f"[red]ERROR:[/red] {message}")
!             else:
!                 print(f"ERROR: {message}", file=sys.stderr)
>         elif level == "warning":
              # Warnings always go to stderr
>             if console_err:
>                 console_err.print(f"[yellow]WARN:[/yellow] {message}")
!             else:
!                 print(f"WARNING: {message}", file=sys.stderr)
>         elif level == "success":
              # Success messages go to stdout
>             if console:
>                 console.print(f"[green]âœ“[/green] {message}")
!             else:
!                 print(f"âœ“ {message}")
>         elif level in ["info", "emit"]:
              # Info and emit messages go to stdout
>             if console:
>                 console.print(message)
!             else:
!                 print(message)
!         else:
              # Default: info/stdout
!             if console:
!                 console.print(message)
!             else:
!                 print(message)
  
>     def list_wrappers(self) -> list[dict[str, str]]:
>         """List all installed wrappers."""
>         wrappers = []
  
>         if not self.bin_dir.exists():
>             return wrappers
  
>         for item in self.bin_dir.iterdir():
>             if item.is_file() and os.access(item, os.X_OK):
>                 if UTILS_AVAILABLE and is_wrapper_file(str(item)):
>                     wrapper_id = get_wrapper_id(str(item))
>                     wrappers.append(
>                         {
>                             "name": item.name,
>                             "path": str(item),
>                             "id": wrapper_id or "unknown",
>                         },
>                     )
>                 else:
                      # Fallback: check if it looks like a wrapper
>                     try:
>                         content = item.read_text()
>                         if "Generated by fplaunchwrapper" in content:
                              # Try to extract ID from content
>                             wrapper_id = "unknown"
>                             for line in content.split("\n"):
>                                 if line.startswith('ID="') and line.endswith('"'):
>                                     wrapper_id = line[4:-1]
>                                     break
>                             wrappers.append(
>                                 {
>                                     "name": item.name,
>                                     "path": str(item),
>                                     "id": wrapper_id,
>                                 },
>                             )
!                     except Exception:
!                         pass
  
>         return wrappers
  
>     def display_wrappers(self) -> None:
>         """Display wrappers in a nice format."""
>         wrappers = self.list_wrappers()
  
>         if not wrappers:
>             if console:
>                 console.print("[yellow]No wrappers found[/yellow]")
>                 console.print(
>                     f"Run 'fplaunch generate {self.bin_dir}' to create wrappers",
>                 )
!             else:
!                 print("No wrappers found")
!                 print(f"Run 'fplaunch generate {self.bin_dir}' to create wrappers")
>             return
  
>         if console:
>             table = Table(title="Flatpak Wrappers")
>             table.add_column("Wrapper", style="cyan", no_wrap=True)
>             table.add_column("Flatpak ID", style="magenta")
>             table.add_column("Path", style="dim")
  
>             for wrapper in wrappers:
>                 table.add_row(wrapper["name"], wrapper["id"], wrapper["path"])
  
>             console.print(table)
>             console.print(f"\n[green]{len(wrappers)}[/green] wrappers found")
!         else:
              # Plain text fallback
!             print("Flatpak Wrappers:")
!             print(f"{'Wrapper':<30} {'Flatpak ID':<30} {'Path'}")
!             print("-" * 90)
!             for wrapper in wrappers:
!                 print(f"{wrapper['name']:<30} {wrapper['id']:<30} {wrapper['path']}")
!             print(f"\n{len(wrappers)} wrappers found")
  
>     def remove_wrapper(self, wrapper_name: str, force: bool = False) -> bool:
>         """Remove a specific wrapper."""
>         wrapper_path = self.bin_dir / wrapper_name
  
>         if not wrapper_path.exists() and not self.emit_mode:
>             self.log(f"Wrapper '{wrapper_name}' not found", "error")
>             return False
  
          # Confirm removal unless forced or in emit mode
>         if not force and not self.emit_mode:
>             if console:
>                 from rich.prompt import Confirm
  
>                 if not Confirm.ask(
>                     f"Are you sure you want to remove wrapper '{wrapper_name}'?",
>                 ):
!                     console.print("[yellow]Removal cancelled[/yellow]")
!                     return False
!             else:
!                 response = input(
!                     f"Are you sure you want to remove wrapper '{wrapper_name}'? (y/n): ",
!                 )
!                 if response.lower() not in ["y", "yes"]:
!                     return False
  
          # In emit mode, just show what would be done
>         if self.emit_mode:
>             self.log(f"EMIT: Would remove wrapper: {wrapper_name}")
>             pref_file = self.config_dir / f"{wrapper_name}.pref"
>             return False
  
          # If we get here in normal (non-emit) mode, return success
>         return 0
  
>     def set_preference(self, wrapper_name: str, preference: str) -> bool:
>         """Set launch preference for a wrapper."""
          # Validate inputs
>         if (
>             not wrapper_name
>             or not isinstance(wrapper_name, str)
>             or not wrapper_name.strip()
>         ):
>             self.log("Invalid wrapper name: must be a non-empty string", "error")
>             return False
  
>         if not preference or not isinstance(preference, str) or not preference.strip():
>             self.log("Invalid preference: must be a non-empty string", "error")
>             return False
  
          # Accept traditional modes and sanitized Flatpak IDs
>         if preference not in ["system", "flatpak"]:
>             import re
  
>             if not re.match(r"^[A-Za-z0-9._-]+$", preference):
>                 self.log(
>                     f"Invalid preference: {preference}. Use 'system', 'flatpak', or a valid Flatpak ID",
>                     "error",
>                 )
>                 return False
  
>         pref_file = self.config_dir / f"{wrapper_name}.pref"
  
>         if self.emit_mode:
>             self.log(f"EMIT: Would write '{preference}' to {pref_file}")
  
              # Show file content if verbose emit mode
>             if self.emit_verbose:
>                 self.log(f"EMIT: File content for {pref_file}:")
>                 if console:
>                     from rich.panel import Panel
  
>                     console.print(
>                         Panel.fit(
>                             preference,
>                             title=f"ðŸ“„ {wrapper_name}.pref preference file",
>                             border_style="green",
>                         ),
>                     )
                      # Also print raw content for tests that capture stdout
>                     print(preference)
!                 else:
!                     self.log("-" * 30)
!                     self.log(f"Content: {preference}")
!                     self.log("-" * 30)
  
>             return True
>         try:
>             pref_file.write_text(preference)
>             self.log(
>                 f"Set preference for '{wrapper_name}' to '{preference}'",
>                 "success",
>             )
>             return True
>         except Exception as e:
>             self.log(f"Failed to set preference for '{wrapper_name}': {e}", "error")
>             return False
  
>     def get_preference(self, wrapper_name: str) -> str | None:
>         """Get launch preference for a wrapper."""
>         pref_file = self.config_dir / f"{wrapper_name}.pref"
  
>         if pref_file.exists():
>             try:
>                 return pref_file.read_text().strip()
!             except Exception:
!                 pass
  
>         return None
  
>     def set_preference_all(self, preference: str) -> int:
>         """Set preference for all wrappers."""
>         if preference not in ["system", "flatpak"]:
!             self.log(
!                 f"Invalid preference: {preference}. Use 'system' or 'flatpak'",
!                 "error",
!             )
!             return 0
  
>         wrappers = self.list_wrappers()
>         updated_count = 0
  
>         for wrapper in wrappers:
>             if self.set_preference(wrapper["name"], preference):
>                 updated_count += 1
  
>         if updated_count > 0:
>             self.log(
>                 f"Set preference to '{preference}' for {updated_count} wrappers",
>                 "success",
>             )
  
>         return updated_count
  
>     def show_info(self, wrapper_name: str) -> bool:
>         """Show detailed information about a wrapper."""
>         wrapper_path = self.bin_dir / wrapper_name
  
>         if not wrapper_path.exists():
>             self.log(f"Wrapper '{wrapper_name}' not found", "error")
>             return False
  
          # Get wrapper information
>         wrapper_id = None
>         preference = self.get_preference(wrapper_name)
  
>         if UTILS_AVAILABLE and is_wrapper_file(str(wrapper_path)):
>             wrapper_id = get_wrapper_id(str(wrapper_path))
  
>         info_lines = [
>             f"Wrapper: {wrapper_name}",
>             f"Path: {wrapper_path}",
>             f"Flatpak ID: {wrapper_id or 'Unknown'}",
>             f"Preference: {preference or 'Not set'}",
>             f"Executable: {'Yes' if os.access(wrapper_path, os.X_OK) else 'No'}",
>         ]
  
>         if console:
>             from rich.panel import Panel
  
>             console.print(
>                 Panel.fit(
>                     "\n".join(info_lines),
>                     title=f"Wrapper Information: {wrapper_name}",
>                 ),
>             )
!         else:
              # Plain text fallback
!             print(f"\nWrapper Information: {wrapper_name}")
!             print("-" * 40)
!             for line in info_lines:
!                 print(line)
!             print()
  
>         return True
  
>     def search_wrappers(self, query: str) -> None:
>         """Search for wrappers matching a query."""
!         wrappers = self.list_wrappers()
!         matches = []
  
!         query = query.lower()
!         for wrapper in wrappers:
!             if (
!                 query in wrapper["name"].lower()
!                 or query in wrapper["id"].lower()
!                 or query in wrapper["path"].lower()
!             ):
!                 matches.append(wrapper)
  
!         if matches:
!             if console:
!                 table = Table(title=f"Search Results for '{query}'")
!                 table.add_column("Wrapper", style="cyan", no_wrap=True)
!                 table.add_column("Flatpak ID", style="magenta")
!                 table.add_column("Path", style="dim")
  
!                 for wrapper in matches:
!                     table.add_row(wrapper["name"], wrapper["id"], wrapper["path"])
  
!                 console.print(table)
!                 console.print(
!                     f"\n[green]{len(matches)}[/green] match{'es' if len(matches) > 1 else ''} found"
!                 )
!             else:
!                 print(f"Search Results for '{query}':")
!                 print(f"{'Wrapper':<30} {'Flatpak ID':<30} {'Path'}")
!                 print("-" * 90)
!                 for wrapper in matches:
!                     print(
!                         f"{wrapper['name']:<30} {wrapper['id']:<30} {wrapper['path']}"
!                     )
!                 print(f"\n{len(matches)} match{'es' if len(matches) > 1 else ''} found")
!         else:
!             if console:
!                 console.print(f"[yellow]No wrappers found matching '{query}'[/yellow]")
!             else:
!                 print(f"No wrappers found matching '{query}'")
  
>     def show_generated_files(self, app_name: str | None = None) -> None:
>         """Show generated files for wrappers.
  
>         Args:
>             app_name: Optional app name to filter files by
>         """
!         if app_name:
              # Show files for specific app
!             wrapper_path = self.bin_dir / app_name
!             pref_file = self.config_dir / f"{app_name}.pref"
!             env_file = self.config_dir / f"{app_name}.env"
!             script_dir = self.config_dir / "scripts" / app_name
!             pre_launch_script = script_dir / "pre-launch.sh"
!             post_run_script = script_dir / "post-run.sh"
  
!             files = []
!             if wrapper_path.exists():
!                 files.append(("Wrapper", str(wrapper_path)))
!             if pref_file.exists():
!                 files.append(("Preference", str(pref_file)))
!             if env_file.exists():
!                 files.append(("Environment", str(env_file)))
!             if pre_launch_script.exists():
!                 files.append(("Pre-launch Script", str(pre_launch_script)))
!             if post_run_script.exists():
!                 files.append(("Post-run Script", str(post_run_script)))
  
!             if files:
!                 if console:
!                     from rich.panel import Panel
!                     from rich.table import Table
  
!                     table = Table()
!                     table.add_column("Type", style="cyan")
!                     table.add_column("Path", style="white")
  
!                     for file_type, file_path in files:
!                         table.add_row(file_type, file_path)
  
!                     console.print(
!                         Panel.fit(table, title=f"Generated Files: {app_name}")
!                     )
!                 else:
!                     print(f"Generated Files: {app_name}")
!                     for file_type, file_path in files:
!                         print(f"  {file_type}: {file_path}")
!             else:
!                 if console:
!                     console.print(
!                         f"[yellow]No generated files found for {app_name}[/yellow]"
!                     )
!                 else:
!                     print(f"No generated files found for {app_name}")
!         else:
              # Show all generated files
!             wrappers = self.list_wrappers()
!             all_files = []
  
!             for wrapper in wrappers:
!                 wrapper_path = self.bin_dir / wrapper["name"]
!                 if wrapper_path.exists():
!                     all_files.append(("Wrapper", str(wrapper_path)))
  
!                 pref_file = self.config_dir / f"{wrapper['name']}.pref"
!                 if pref_file.exists():
!                     all_files.append(("Preference", str(pref_file)))
  
!                 env_file = self.config_dir / f"{wrapper['name']}.env"
!                 if env_file.exists():
!                     all_files.append(("Environment", str(env_file)))
  
!                 script_dir = self.config_dir / "scripts" / wrapper["name"]
!                 pre_launch_script = script_dir / "pre-launch.sh"
!                 if pre_launch_script.exists():
!                     all_files.append(("Pre-launch Script", str(pre_launch_script)))
  
!                 post_run_script = script_dir / "post-run.sh"
!                 if post_run_script.exists():
!                     all_files.append(("Post-run Script", str(post_run_script)))
  
!             if all_files:
!                 if console:
!                     table = Table(title="All Generated Files")
!                     table.add_column("Type", style="cyan")
!                     table.add_column("Path", style="white")
  
!                     for file_type, file_path in all_files:
!                         table.add_row(file_type, file_path)
  
!                     console.print(table)
!                     console.print(
!                         f"\n[green]{len(all_files)}[/green] generated file{'s' if len(all_files) > 1 else ''} found"
!                     )
!                 else:
!                     print("All Generated Files:")
!                     print(f"{'Type':<20} {'Path'}")
!                     print("-" * 80)
!                     for file_type, file_path in all_files:
!                         print(f"{file_type:<20} {file_path}")
!                     print(
!                         f"\n{len(all_files)} generated file{'s' if len(all_files) > 1 else ''} found"
!                     )
!             else:
!                 if console:
!                     console.print("[yellow]No generated files found[/yellow]")
!                 else:
!                     print("No generated files found")
  
>     def discover_features(self) -> None:
>         """Discover and show available features."""
>         features = [
>             (
>                 "Wrapper Generation",
>                 "Automatically create launch scripts for Flatpak apps",
>             ),
>             ("Launch Preferences", "Choose between system packages and Flatpak apps"),
>             ("Automatic Updates", "Monitor for app changes and update wrappers"),
>             ("Interactive Mode", "Choose launch method interactively"),
>             ("Script Integration", "Pre/post-launch scripts for customization"),
>             ("Alias Support", "Create custom aliases for wrappers"),
>             ("Configuration", "TOML-based configuration with validation"),
>         ]
  
>         if console:
>             table = Table(title="fplaunchwrapper Features")
>             table.add_column("Feature", style="cyan", no_wrap=True)
>             table.add_column("Description", style="white")
  
>             for feature, description in features:
>                 table.add_row(feature, description)
  
>             console.print(table)
  
              # Show usage examples
>             console.print("\n[bold]Usage Examples:[/bold]")
>             examples = [
>                 "fplaunch generate ~/bin          # Generate wrappers",
>                 "fplaunch list                     # List all wrappers",
>                 "fplaunch set-pref firefox flatpak # Set preference",
>                 "fplaunch monitor                  # Monitor for changes",
>                 "firefox --fpwrapper-help          # Wrapper help",
>             ]
  
>             for example in examples:
>                 console.print(f"  [green]$[/green] {example}")
!         else:
              # Plain text fallback
!             print("fplaunchwrapper Features:")
!             print(f"{'Feature':<25} {'Description'}")
!             print("-" * 70)
!             for feature, description in features:
!                 print(f"{feature:<25} {description}")
!             print("\nUsage Examples:")
!             examples = [
!                 "fplaunch generate ~/bin          # Generate wrappers",
!                 "fplaunch list                     # List all wrappers",
!                 "fplaunch set-pref firefox flatpak # Set preference",
!                 "fplaunch monitor                  # Monitor for changes",
!                 "firefox --fpwrapper-help          # Wrapper help",
!             ]
!             for example in examples:
!                 print(f"  $ {example}")
  
>     def cleanup_obsolete(self) -> int:
>         """Clean up wrappers for uninstalled applications."""
!         self.log("Cleaning up obsolete wrappers...")
  
          # Check if Flatpak is available
!         try:
!             from .generate import WrapperGenerator
  
!             gen = WrapperGenerator(
!                 str(self.bin_dir), self.verbose, self.emit_mode, self.emit_verbose
!             )
!             installed_apps = gen.get_installed_flatpaks()
!         except (ImportError, RuntimeError) as e:
!             self.log(f"Could not get installed Flatpak apps: {e}", "warning")
!             return 0
  
!         removed_count = 0
  
          # Get existing wrappers
!         if not self.bin_dir.exists():
!             return 0
  
!         for item in self.bin_dir.iterdir():
!             if not item.is_file():
!                 continue
  
!             remove_item = False
  
              # Check if it's a wrapper
!             if UTILS_AVAILABLE:
!                 try:
!                     from .python_utils import is_wrapper_file, get_wrapper_id
  
!                     if is_wrapper_file(str(item)):
!                         wrapper_id = get_wrapper_id(str(item))
!                         if wrapper_id and wrapper_id not in installed_apps:
!                             remove_item = True
!                 except Exception:
                      # If we can't determine, don't remove
!                     pass
!             else:
                  # Fallback: treat file as potential wrapper
!                 try:
!                     from .python_utils import sanitize_id_to_name
  
!                     sanitized_installed = [
!                         sanitize_id_to_name(a) for a in installed_apps
!                     ]
!                     if item.name not in sanitized_installed:
!                         remove_item = True
!                 except Exception:
!                     pass
  
!             if remove_item:
!                 if self.emit_mode:
!                     self.log(f"EMIT: Would remove obsolete wrapper: {item.name}")
!                     removed_count += 1
!                 else:
!                     try:
!                         item.unlink()
!                         self.log(f"Removed obsolete wrapper: {item.name}", "success")
!                         removed_count += 1
  
                          # Remove preference file
!                         pref_file = self.config_dir / f"{item.name}.pref"
!                         if pref_file.exists():
!                             pref_file.unlink()
  
                          # Remove aliases
!                         aliases_file = self.config_dir / "aliases"
!                         if aliases_file.exists():
!                             try:
!                                 content = aliases_file.read_text()
!                                 new_content = "\n".join(
!                                     line
!                                     for line in content.split("\n")
!                                     if not line.startswith(f"{item.name} ")
!                                 )
!                                 if new_content.strip():
!                                     aliases_file.write_text(new_content)
!                                 else:
!                                     aliases_file.unlink()
!                             except Exception as e:
!                                 self.log(
!                                     f"Warning: Could not clean up aliases: {e}",
!                                     "warning",
!                                 )
!                     except Exception as e:
!                         self.log(
!                             f"Failed to remove obsolete wrapper {item.name}: {e}",
!                             "error",
!                         )
  
!         if removed_count > 0:
!             self.log(f"Cleaned up {removed_count} obsolete wrapper(s)", "success")
!         else:
!             self.log("No obsolete wrappers found")
  
!         return removed_count
  
>     def _resolve_alias_chain(
>         self, alias_name: str, aliases: dict[str, str]
>     ) -> list[str]:
>         """Resolve an alias to its final target, following all alias chains.
  
>         Args:
>             alias_name: The alias to resolve
>             aliases: Dictionary of existing aliases
  
>         Returns:
>             List representing the alias chain (including the starting alias)
  
>         Raises:
>             RuntimeError: If a circular reference is detected
>         """
>         chain = []
>         current = alias_name
  
>         while current:
>             if current in chain:
                  # Circular reference detected
>                 chain.append(current)
>                 cycle_str = " -> ".join(chain)
>                 raise RuntimeError(f"Circular alias reference detected: {cycle_str}")
  
>             chain.append(current)
  
>             if current not in aliases:
                  # Reached the end of the chain (not an alias)
>                 break
  
>             current = aliases[current]
  
>         return chain
  
>     def _check_system_command_collision(self, name: str) -> bool:
>         """Check if a name collides with a system command available in PATH.
  
>         Args:
>             name: The name to check
  
>         Returns:
>             True if name collides with a system command, False otherwise
>         """
>         import shutil
  
>         return shutil.which(name) is not None
  
>     def _check_collision(self, alias_name: str) -> str | None:
>         """Check for namespace collisions with existing wrappers, aliases, or system commands.
  
>         Args:
>             alias_name: The alias name to check for collisions
  
>         Returns:
>             Collision type as string if collision detected, None otherwise
>         """
          # Check for collision with existing wrapper
>         wrapper_path = self.bin_dir / alias_name
>         if wrapper_path.exists():
>             return "wrapper"
  
          # Check for collision with system command
>         if self._check_system_command_collision(alias_name):
!             return "system_command"
  
>         return None
  
>     def create_alias(
>         self, alias_name: str, target_wrapper: str, validate_target: bool = False
>     ) -> bool:
>         """Create an alias for a wrapper with comprehensive collision detection and validation.
  
>         Args:
>             alias_name: Name of the alias to create
>             target_wrapper: Name of the target wrapper to alias to
>             validate_target: If True, verify target wrapper exists (default: False for flexibility)
  
>         Validates that:
>         - The alias name doesn't collide with existing wrappers
>         - The alias name doesn't collide with system commands
>         - The alias name doesn't already exist
>         - The alias doesn't create a circular reference
>         - Optionally checks that the target wrapper exists
>         """
>         self.log(f"Creating alias '{alias_name}' -> '{target_wrapper}'...")
  
          # Validate inputs
>         if not alias_name or not isinstance(alias_name, str) or not alias_name.strip():
>             self.log("Invalid alias name: must be a non-empty string", "error")
>             return False
  
>         if (
>             not target_wrapper
>             or not isinstance(target_wrapper, str)
>             or not target_wrapper.strip()
>         ):
>             self.log("Invalid target wrapper: must be a non-empty string", "error")
>             return False
  
          # Store aliases in config file
>         aliases_file = self.config_dir / "aliases"
  
>         try:
              # Check for namespace collisions
>             collision_type = self._check_collision(alias_name)
>             if collision_type:
>                 if collision_type == "wrapper":
>                     self.log(
>                         f"Error: Alias name '{alias_name}' collides with an existing wrapper",
>                         "error",
>                     )
!                 elif collision_type == "system_command":
!                     self.log(
!                         f"Error: Alias name '{alias_name}' collides with a system command",
!                         "error",
!                     )
>                 return False
  
              # Check if target wrapper exists (optional validation)
>             if validate_target:
>                 target_path = self.bin_dir / target_wrapper
>                 if not target_path.exists():
>                     self.log(
>                         f"Error: Target wrapper '{target_wrapper}' not found", "error"
>                     )
>                     return False
  
              # Read existing aliases
>             if aliases_file.exists():
>                 aliases_content = aliases_file.read_text()
>                 aliases = dict(
>                     line.split(":", 1)
>                     for line in aliases_content.strip().split("\n")
>                     if ":" in line and len(line.split(":", 1)) == 2
>                 )
>             else:
>                 aliases = {}
  
              # Check if alias already exists
>             if alias_name in aliases:
>                 self.log(
>                     f"Error: Alias '{alias_name}' already exists -> '{aliases[alias_name]}'",
>                     "error",
>                 )
>                 return False
  
              # Check for circular references by simulating the new alias chain
>             temp_aliases = aliases.copy()
>             temp_aliases[alias_name] = target_wrapper
  
>             try:
>                 self._resolve_alias_chain(alias_name, temp_aliases)
>             except RuntimeError as e:
>                 self.log(f"Error: {e}", "error")
>                 return False
  
              # Resolve target alias chain for informational purposes
>             if target_wrapper in aliases:
>                 try:
>                     target_chain = self._resolve_alias_chain(target_wrapper, aliases)
>                     chain_str = " -> ".join([alias_name] + target_chain[1:])
>                     self.log(f"Info: Complete alias chain will be: {chain_str}", "info")
!                 except Exception as e:
!                     self.log(
!                         f"Warning: Could not resolve target alias chain: {e}", "warning"
!                     )
  
              # Add new alias
>             aliases[alias_name] = target_wrapper
  
              # Write back to file
>             if self.emit_mode:
>                 self.log(
>                     f"EMIT: Would write alias '{alias_name}' -> '{target_wrapper}' to {aliases_file}"
>                 )
>             else:
>                 aliases_file.write_text(
>                     "\n".join(f"{k}:{v}" for k, v in sorted(aliases.items())) + "\n"
>                 )
  
>             self.log(f"Created alias: {alias_name} -> {target_wrapper}", "success")
>             return True
!         except Exception as e:
!             self.log(f"Failed to create alias: {e}", "error")
!             return False
  
>     def block_app(self, app_id: str) -> bool:
>         """Add an application to the blocklist."""
>         self.log(f"Blocking application: {app_id}...")
  
>         blocklist_file = self.config_dir / "blocklist"
  
>         try:
              # Read existing blocklist
>             if blocklist_file.exists():
>                 blocklist = set(blocklist_file.read_text().strip().split("\n"))
>             else:
>                 blocklist = set()
  
              # Add app to blocklist
>             if app_id in blocklist:
>                 self.log(f"Application '{app_id}' already blocked", "warning")
>                 return True
  
>             blocklist.add(app_id)
>             blocklist_file.write_text("\n".join(sorted(blocklist)) + "\n")
  
>             self.log(f"Blocked application: {app_id}", "success")
>             return True
!         except Exception as e:
!             self.log(f"Failed to block application: {e}", "error")
!             return False
  
>     def unblock_app(self, app_id: str) -> bool:
>         """Remove an application from the blocklist."""
>         self.log(f"Unblocking application: {app_id}...")
  
>         blocklist_file = self.config_dir / "blocklist"
  
>         try:
>             if not blocklist_file.exists():
!                 self.log(f"Application '{app_id}' not in blocklist", "warning")
!                 return True  # Idempotent - return True even if not blocked
  
              # Read existing blocklist
>             blocklist = set(blocklist_file.read_text().strip().split("\n"))
  
              # Remove app from blocklist
>             if app_id not in blocklist:
>                 self.log(f"Application '{app_id}' not in blocklist", "warning")
>                 return True  # Idempotent - return True even if not blocked
  
>             blocklist.remove(app_id)
>             if blocklist:
>                 blocklist_file.write_text("\n".join(sorted(blocklist)) + "\n")
>             else:
>                 blocklist_file.unlink()
  
>             self.log(f"Unblocked application: {app_id}", "success")
>             return True
!         except Exception as e:
!             self.log(f"Failed to unblock application: {e}", "error")
!             return False
  
>     def set_environment_variable(
>         self, wrapper_name: str, var_name: str, var_value: str
>     ) -> bool:
>         """Set an environment variable for a wrapper."""
>         self.log(f"Setting {var_name}={var_value} for {wrapper_name}...")
  
>         env_file = self.config_dir / f"{wrapper_name}.env"
  
>         try:
              # Read existing env file if it exists
>             if env_file.exists():
>                 content = env_file.read_text()
>                 lines = content.strip().split("\n")
>             else:
>                 lines = []
  
              # Update or add the variable
>             found = False
>             for i, line in enumerate(lines):
>                 if line.startswith(f"{var_name}="):
>                     lines[i] = f"{var_name}={var_value}"
>                     found = True
>                     break
  
>             if not found:
>                 lines.append(f"{var_name}={var_value}")
  
              # Write back to file
>             env_file.write_text("\n".join(lines) + "\n" if lines else "")
  
>             self.log(f"Set environment variable: {var_name}", "success")
>             return True
!         except Exception as e:
!             self.log(f"Failed to set environment variable: {e}", "error")
!             return False
  
>     def export_preferences(self, export_path: str) -> bool:
>         """Export preferences and aliases to a file."""
>         self.log(f"Exporting preferences to {export_path}...")
  
>         try:
>             import json
  
>             data = {"preferences": {}, "aliases": {}, "environment_variables": {}}
>             pref_dir = self.config_dir
  
              # Collect all .pref files
>             for pref_file in pref_dir.glob("*.pref"):
>                 wrapper_name = pref_file.stem
>                 preference = pref_file.read_text().strip()
>                 data["preferences"][wrapper_name] = preference
  
              # Collect aliases
>             aliases_file = self.config_dir / "aliases"
>             if aliases_file.exists():
>                 aliases_content = aliases_file.read_text()
>                 for line in aliases_content.strip().split("\n"):
>                     if ":" in line:
>                         alias, target = line.split(":", 1)
>                         data["aliases"][alias] = target
  
              # Collect environment variables
>             for env_file in pref_dir.glob("*.env"):
>                 wrapper_name = env_file.stem
>                 env_content = env_file.read_text().strip()
>                 if env_content:
>                     env_vars = {}
>                     for line in env_content.split("\n"):
>                         if "=" in line:
>                             key, value = line.split("=", 1)
>                             env_vars[key] = value
>                     if env_vars:
>                         data["environment_variables"][wrapper_name] = env_vars
  
              # Write to export file
>             Path(export_path).write_text(json.dumps(data, indent=2))
  
>             self.log(f"Exported {len(data['preferences'])} preferences", "success")
>             return True
!         except Exception as e:
!             self.log(f"Failed to export preferences: {e}", "error")
!             return False
  
>     def import_preferences(self, import_path: str) -> bool:
>         """Import preferences and aliases from a file."""
>         self.log(f"Importing preferences from {import_path}...")
  
>         try:
>             import json
  
>             import_file = Path(import_path)
>             if not import_file.exists():
!                 self.log(f"Import file not found: {import_path}", "error")
!                 return False
  
>             data = json.loads(import_file.read_text())
  
              # Handle both old format (just prefs) and new format (prefs + aliases + env vars)
>             if "preferences" in data:
>                 preferences = data["preferences"]
>                 aliases = data.get("aliases", {})
>                 environment_variables = data.get("environment_variables", {})
!             else:
                  # Old format - just preferences
!                 preferences = data
!                 aliases = {}
!                 environment_variables = {}
  
              # Apply each preference
>             count = 0
>             for wrapper_name, preference in preferences.items():
>                 if self.set_preference(wrapper_name, preference):
>                     count += 1
  
              # Apply aliases
>             if aliases:
>                 aliases_file = self.config_dir / "aliases"
>                 aliases_content = (
>                     "\n".join(f"{k}:{v}" for k, v in aliases.items()) + "\n"
>                 )
>                 aliases_file.write_text(aliases_content)
  
              # Apply environment variables
>             for wrapper_name, env_vars in environment_variables.items():
>                 env_file = self.config_dir / f"{wrapper_name}.env"
>                 env_content = "\n".join(f"{k}={v}" for k, v in env_vars.items()) + "\n"
>                 env_file.write_text(env_content)
  
>             self.log(f"Imported {count} preferences", "success")
>             return True
!         except Exception as e:
!             self.log(f"Failed to import preferences: {e}", "error")
!             return False
  
>     def set_pre_launch_script(self, wrapper_name: str, script_content: str) -> bool:
>         """Set a pre-launch script for a wrapper."""
>         self.log(f"Setting pre-launch script for {wrapper_name}...")
  
>         script_dir = self.config_dir / "scripts" / wrapper_name
>         script_dir.mkdir(parents=True, exist_ok=True)
  
>         script_file = script_dir / "pre-launch.sh"
  
>         try:
>             script_file.write_text(script_content)
>             script_file.chmod(0o755)
>             self.log(f"Set pre-launch script for {wrapper_name}", "success")
>             return True
!         except Exception as e:
!             self.log(f"Failed to set pre-launch script: {e}", "error")
!             return False
  
>     def set_post_run_script(self, wrapper_name: str, script_content: str) -> bool:
>         """Set post-run script for a wrapper."""
>         self.log(f"Setting post-run script for {wrapper_name}...")
  
>         script_dir = self.config_dir / "scripts" / wrapper_name
>         script_dir.mkdir(parents=True, exist_ok=True)
  
>         script_file = script_dir / "post-run.sh"
  
>         try:
>             script_file.write_text(script_content)
>             script_file.chmod(0o755)
>             self.log(f"Set post-run script for {wrapper_name}", "success")
>             return True
!         except Exception as e:
!             self.log(f"Failed to set post-run script: {e}", "error")
!             return False
  
      # Safe integration test methods
>     def install_app(self, app_id: str) -> bool:
>         """Simulate app installation for testing."""
>         self.log(f"Simulating installation of {app_id}")
>         return True
  
>     def enable_app(self, app_id: str) -> bool:
>         """Simulate enabling app for testing."""
>         self.log(f"Simulating enabling of {app_id}")
>         return True
  
>     def disable_app(self, app_id: str) -> bool:
>         """Simulate disabling app for testing."""
>         self.log(f"Simulating disabling of {app_id}")
>         return True
  
>     def update_app(self, app_id: str) -> bool:
>         """Simulate updating app for testing."""
>         self.log(f"Simulating update of {app_id}")
>         return True
  
>     def remove_app(self, app_id: str) -> bool:
>         """Simulate removing app for testing."""
>         self.log(f"Simulating removal of {app_id}")
>         return True
  
  
> def main() -> int | None:
>     """Command-line interface for wrapper management."""
>     import argparse
  
>     parser = argparse.ArgumentParser(
>         description="Manage Flatpak application wrappers",
>         formatter_class=argparse.RawDescriptionHelpFormatter,
>     )
  
>     parser.add_argument(
>         "command",
>         choices=[
>             "list",
>             "remove",
>             "rm",
>             "set-pref",
>             "info",
>             "discover",
>             "search",
>             "cleanup",
>         ],
>         help="Command to execute",
>     )
  
>     parser.add_argument("args", nargs="*", help="Command arguments")
  
>     parser.add_argument("--config-dir", "-c", help="Configuration directory")
  
>     parser.add_argument(
>         "--verbose",
>         "-v",
>         action="store_true",
>         help="Enable verbose output",
>     )
  
>     parser.add_argument(
>         "--force",
>         "-f",
>         action="store_true",
>         help="Force operations without confirmation",
>     )
  
>     parser.add_argument(
>         "--emit",
>         action="store_true",
>         help="Emit commands instead of executing (dry run)",
>     )
  
>     args = parser.parse_args()
  
>     manager = WrapperManager(args.config_dir, args.verbose, args.emit)
  
>     command = args.command
>     if command == "search":
>         command = "discover"
>     elif command == "rm":
>         command = "remove"
  
>     try:
>         if command == "list":
!             manager.display_wrappers()
  
>         elif command == "remove":
>             if not args.args:
!                 parser.error("remove requires a wrapper name")
>             success = manager.remove_wrapper(args.args[0], args.force)
>             return 0 if success else 1
  
>         elif command == "set-pref":
!             if len(args.args) != 2:
!                 parser.error(
!                     "set-pref requires wrapper name and preference (system|flatpak)",
!                 )
!             success = manager.set_preference(args.args[0], args.args[1])
!             return 0 if success else 1
  
>         elif command == "info":
!             if not args.args:
!                 parser.error("info requires a wrapper name")
!             success = manager.show_info(args.args[0])
!             return 0 if success else 1
  
>         elif command == "discover":
>             manager.discover_features()
  
>         elif command == "cleanup":
>             removed_count = manager.cleanup_obsolete()
>             manager.log(f"Cleaned up {removed_count} obsolete wrappers")
  
>         return 0
  
!     except Exception as e:
!         if console:
!             console.print(f"[red]Error:[/red] {e}")
!         else:
!             pass
!         return 1
  
  
> if __name__ == "__main__":
!     sys.exit(main())
