#!/usr/bin/env bash
# Test script to verify name clash handling in fplaunchwrapper
# Run this to test various collision scenarios

set -e

# Configuration
TEST_BIN_DIR="/tmp/fplaunch-test-bin"
TEST_CONFIG_DIR="/tmp/fplaunch-test-config"

# Cleanup function
cleanup() {
    echo "Cleaning up test environment..."
    rm -rf "$TEST_BIN_DIR" "$TEST_CONFIG_DIR"
}

# Setup test environment
setup_test_env() {
    echo "Setting up test environment..."
    mkdir -p "$TEST_BIN_DIR" "$TEST_CONFIG_DIR"
    
    # Mock XDG_CONFIG_HOME for this test
    export XDG_CONFIG_HOME="/tmp"
    
    # Create mock flatpak command
    cat > "$TEST_BIN_DIR/flatpak" << 'EOF'
#!/bin/bash
case "$1" in
    "list")
        if [[ "$*" == *"--app"* ]]; then
            # Simulate conflicting app IDs
            echo "com.visualstudio.code"
            echo "com.visualstudio.code-oss" 
            echo "org.gnome.gedit"
            echo "org.gnome.calculator"
            echo "org.libreoffice.LibreOffice"
        fi
        ;;
    "info")
        # Mock flatpak info output
        echo "Ref: app/com.visualstudio.code/x86_64/stable"
        echo "ID: com.visualstudio.code"
        echo "Arch: x86_64"
        echo "Branch: stable"
        ;;
    *)
        echo "Mock flatpak: $*"
        ;;
esac
EOF
    chmod +x "$TEST_BIN_DIR/flatpak"
    
    # Add test bin to PATH
    export PATH="$TEST_BIN_DIR:$PATH"
}

# Test 1: Wrapper name collision
test_wrapper_collision() {
    echo -e "\n=== Testing wrapper name collision ==="
    
    # Create two apps that would generate the same wrapper name
    APP_IDS=("com.visualstudio.code" "com.visualstudio.code-oss")
    
    # Mock the generate script to create wrappers
    for app_id in "${APP_IDS[@]}"; do
        name=$(echo "$app_id" | awk -F. '{print tolower($NF)}')
        wrapper_path="$TEST_BIN_DIR/$name"
        
        echo "Creating wrapper for $app_id -> $name"
        
        if [ -f "$wrapper_path" ]; then
            echo "WARNING: Wrapper $name already exists - this tests collision handling"
            echo "Previous content hash: $(cat "$wrapper_path" | head -1)"
        fi
        
        # Create wrapper
        cat > "$wrapper_path" << EOF
#!/usr/bin/env bash
# Generated by fplaunchwrapper for $app_id
echo "Wrapper for $app_id"
ID="$app_id"
EOF
        chmod +x "$wrapper_path"
        
        echo "Created: $wrapper_path"
    done
    
    echo "Final wrapper content:"
    cat "$TEST_BIN_DIR/code"
}

# Test 2: Alias collision
test_alias_collision() {
    echo -e "\n=== Testing alias collision ==="
    
    # Create a wrapper first
    wrapper_name="testapp"
    alias_name="myalias"
    
    cat > "$TEST_BIN_DIR/$wrapper_name" << EOF
#!/usr/bin/env bash
echo "Test wrapper"
EOF
    chmod +x "$TEST_BIN_DIR/$wrapper_name"
    
    # Create first alias
    if [ ! -e "$TEST_BIN_DIR/$alias_name" ]; then
        ln -s "$TEST_BIN_DIR/$wrapper_name" "$TEST_BIN_DIR/$alias_name"
        echo "$wrapper_name $alias_name" >> "$TEST_CONFIG_DIR/aliases"
        echo "Created first alias: $alias_name -> $wrapper_name"
    else
        echo "Alias $alias_name already exists"
    fi
    
    # Try to create conflicting alias (simulate the logic from manage_wrappers.sh:272)
    if [ -e "$TEST_BIN_DIR/$alias_name" ]; then
        echo "ERROR: Alias $alias_name already exists (this is expected)"
        echo "This tests the collision detection in set_alias()"
    fi
    
    # Try creating alias with different target
    echo "Testing alias collision handling..."
    if [ -L "$TEST_BIN_DIR/$alias_name" ]; then
        echo "Alias exists, checking if it points to different target..."
        current_target=$(readlink "$TEST_BIN_DIR/$alias_name")
        echo "Current alias target: $current_target"
    fi
}

# Test 3: System command conflict simulation
test_system_conflict() {
    echo -e "\n=== Testing system vs flatpak command conflict ==="
    
    # Create a mock system command (simulates system-installed app)
    system_cmd="gedit"
    cat > "$TEST_BIN_DIR/$system_cmd" << EOF
#!/usr/bin/env bash
echo "System package: $system_cmd"
echo "Path: \$(which $system_cmd)"
EOF
    chmod +x "$TEST_BIN_DIR/$system_cmd"
    
    echo "Created system command: $TEST_BIN_DIR/$system_cmd"
    
    # Create Flatpak wrapper with same name (simulates org.gnome.gedit -> gedit)
    wrapper_name="$system_cmd"
    cat > "$TEST_BIN_DIR/${wrapper_name}.flatpak-wrapper" << EOF
#!/usr/bin/env bash
# Generated by fplaunchwrapper for org.gnome.gedit
NAME="$wrapper_name"
ID="org.gnome.gedit"
PREF_DIR="\$HOME/.config/flatpak-wrappers"
PREF_FILE="\$PREF_DIR/\$NAME.pref"
SCRIPT_BIN_DIR="$TEST_BIN_DIR"

# Check for system command at launch time (from fplaunch-generate:278-285)
SYSTEM_EXISTS=false
if command -v "\$NAME" >/dev/null 2>&1; then
    CMD_PATH=\$(which "\$NAME")
    if [[ "\$CMD_PATH" != "\$SCRIPT_BIN_DIR/\$NAME" ]]; then
        SYSTEM_EXISTS=true
    fi
fi

if [ -f "\$PREF_FILE" ]; then
    PREF=\$(cat "\$PREF_FILE")
else
    PREF=""
fi

# No pref set - show choice to user (from fplaunch-generate:305-310)
if [ "\$PREF" = "" ] && [ "\$SYSTEM_EXISTS" = true ]; then
    echo "Multiple options for '\$NAME':"
    echo "1. System package (\$CMD_PATH)"
    echo "2. Flatpak app (\$ID)"
    echo "User would be prompted to choose..."
    
    # Simulate user choice
    echo "Simulating user choice: 1 (system) or 2 (flatpak)"
    read -r -p "Choose (1/2, default 1): " choice
    choice=\${choice:-1}
    
    if [ "\$choice" = "1" ]; then
        echo "User chose system package"
        echo "system" > "\$PREF_FILE"
        exec "\$NAME" "\$@"
    elif [ "\$choice" = "2" ]; then
        echo "User chose Flatpak app"
        echo "flatpak" > "\$PREF_FILE"
        exec flatpak run "\$ID" "\$@"
    else
        echo "Invalid choice, defaulting to system"
        echo "system" > "\$PREF_FILE"
        exec "\$NAME" "\$@"
    fi
else
    echo "No conflict or preference already set"
fi
EOF
    chmod +x "$TEST_BIN_DIR/${wrapper_name}.flatpak-wrapper"
    
    echo "Created Flatpak wrapper: $TEST_BIN_DIR/${wrapper_name}.flatpak-wrapper"
    
    # Test the conflict detection logic
    echo -e "\nTesting conflict detection:"
    if command -v "$system_cmd" >/dev/null 2>&1; then
        cmd_path=$(which "$system_cmd")
        echo "System command found: $cmd_path"
        if [[ "$cmd_path" != "$TEST_BIN_DIR/$system_cmd" ]]; then
            echo "✓ System command detected (not our wrapper)"
        else
            echo "✓ System command detected (our mock)"
        fi
    else
        echo "No system command found"
    fi
    
    echo -e "\nThis tests the logic in fplaunch-generate:278-325"
    echo "Users get to choose between system and flatpak versions!"
}

# Test 4: Invalid name handling
test_invalid_names() {
    echo -e "\n=== Testing invalid name handling ==="
    
    # Test names that should be skipped (from fplaunch-generate:53-55)
    invalid_ids=("com.example.invalid-name!" "com.example.test@special" "com.example.space name")
    
    for app_id in "${invalid_ids[@]}"; do
        name=$(echo "$app_id" | awk -F. '{print tolower($NF)}')
        echo "Testing invalid name: $app_id -> $name"
        
        # Check if name contains invalid characters
        if [[ "$name" =~ [^a-z0-9_-] ]]; then
            echo "  ✓ Name '$name' correctly identified as invalid (contains special chars)"
        else
            echo "  ✗ Name '$name' should be invalid but wasn't caught"
        fi
        
        # Check for empty names
        if [ -z "$name" ]; then
            echo "  ✓ Empty name correctly handled"
        fi
    done
}

# Test 5: Test wrapper overwriting behavior
test_wrapper_overwriting() {
    echo -e "\n=== Testing preference persistence and fallback ==="
    
    app_name="testapp"
    pref_file="$TEST_CONFIG_DIR/$app_name.pref"
    
    echo "Testing preference file handling:"
    
    # Test 1: No preference set
    echo "1. No preference set:"
    if [ -f "$pref_file" ]; then
        pref=$(cat "$pref_file")
        echo "   Current preference: $pref"
    else
        echo "   No preference file exists"
    fi
    
    # Test 2: Set system preference
    echo -e "\n2. Setting system preference:"
    echo "system" > "$pref_file"
    echo "   Preference set to: $(cat "$pref_file")"
    
    # Test 3: System command disappears (fallback logic)
    echo -e "\n3. Testing system command fallback:"
    # Remove the system command
    rm -f "$TEST_BIN_DIR/$app_name"
    
    # Simulate the fallback logic from fplaunch-generate:287-298
    if [ -f "$pref_file" ]; then
        pref=$(cat "$pref_file")
        echo "   Stored preference: $pref"
        
        if [ "$pref" = "system" ]; then
            if command -v "$app_name" >/dev/null 2>&1; then
                echo "   ✓ System command exists, using system"
            else
                echo "   ✓ System command missing, falling back to flatpak"
                echo "flatpak" > "$pref_file"
                echo "   Updated preference to: $(cat "$pref_file")"
            fi
        fi
    fi
    
    # Test 4: Set flatpak preference
    echo -e "\n4. Setting flatpak preference:"
    echo "flatpak" > "$pref_file"
    echo "   Preference set to: $(cat "$pref_file")"
    
    echo -e "\n✓ Preference persistence tested"
    echo "This covers the logic in fplaunch-generate:272-298"
}

# Test 5: Preference persistence and fallback
test_preference_persistence() {
    echo -e "\n=== Testing preference persistence and fallback ==="
    
    app_name="testapp"
    pref_file="$TEST_CONFIG_DIR/$app_name.pref"
    
    echo "Testing preference file handling:"
    
    # Test 1: No preference set
    echo "1. No preference set:"
    if [ -f "$pref_file" ]; then
        pref=$(cat "$pref_file")
        echo "   Current preference: $pref"
    else
        echo "   No preference file exists"
    fi
    
    # Test 2: Set system preference
    echo -e "\n2. Setting system preference:"
    echo "system" > "$pref_file"
    echo "   Preference set to: $(cat "$pref_file")"
    
    # Test 3: System command disappears (fallback logic)
    echo -e "\n3. Testing system command fallback:"
    # Remove the system command
    rm -f "$TEST_BIN_DIR/$app_name"
    
    # Simulate the fallback logic from fplaunch-generate:287-298
    if [ -f "$pref_file" ]; then
        pref=$(cat "$pref_file")
        echo "   Stored preference: $pref"
        
        if [ "$pref" = "system" ]; then
            if command -v "$app_name" >/dev/null 2>&1; then
                echo "   ✓ System command exists, using system"
            else
                echo "   ✓ System command missing, falling back to flatpak"
                echo "flatpak" > "$pref_file"
                echo "   Updated preference to: $(cat "$pref_file")"
            fi
        fi
    fi
    
    # Test 4: Set flatpak preference
    echo -e "\n4. Setting flatpak preference:"
    echo "flatpak" > "$pref_file"
    echo "   Preference set to: $(cat "$pref_file")"
    
    echo -e "\n✓ Preference persistence tested"
    echo "This covers the logic in fplaunch-generate:272-298"
}

# Test 6: Test wrapper overwriting behavior
test_wrapper_overwriting() {
    echo -e "\n=== Testing wrapper overwriting behavior ==="
    
    # Create original wrapper
    wrapper_name="testapp"
    original_content="#!/usr/bin/env bash\necho 'Original wrapper'"
    echo "$original_content" > "$TEST_BIN_DIR/$wrapper_name"
    chmod +x "$TEST_BIN_DIR/$wrapper_name"
    
    echo "Original wrapper created:"
    cat "$TEST_BIN_DIR/$wrapper_name"
    
    # Simulate wrapper regeneration (like fplaunch-generate:57)
    new_content="#!/usr/bin/env bash\necho 'Updated wrapper'\nID='org.example.new'"
    echo "$new_content" > "$TEST_BIN_DIR/$wrapper_name"
    chmod +x "$TEST_BIN_DIR/$wrapper_name"
    
    echo -e "\nWrapper after regeneration:"
    cat "$TEST_BIN_DIR/$wrapper_name"
    
    echo -e "\n✓ Wrapper was silently overwritten (current behavior)"
    echo "  This tests the overwriting logic in fplaunch-generate:57"
}

# Run all tests
main() {
    echo "Testing fplaunchwrapper name clash handling"
    echo "=========================================="
    
    setup_test_env
    
    test_wrapper_collision
    test_alias_collision  
    test_system_conflict
    test_invalid_names
    test_preference_persistence
    test_wrapper_overwriting
    
    echo -e "\n=== Test Summary ==="
    echo "Test environment: $TEST_BIN_DIR"
    echo "Config directory: $TEST_CONFIG_DIR"
    echo "Files created:"
    find "$TEST_BIN_DIR" "$TEST_CONFIG_DIR" -type f 2>/dev/null | sort
    
    cleanup
    echo -e "\n✓ All tests completed"
}

# Run if called directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi