#!/usr/bin/env bash
# Test suite for wrapper generation functionality
# Self-contained test that doesn't require actual Flatpak installation

TEST_DIR="/tmp/fplaunch-test-$$"
TEST_BIN="$TEST_DIR/bin"
TEST_CONFIG="$TEST_DIR"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

TESTS_PASSED=0
TESTS_FAILED=0

# Cleanup function
cleanup() {
    rm -rf "$TEST_DIR"
}
trap cleanup EXIT

# Test helper functions
assert_file_exists() {
    if [ -f "$1" ]; then
        echo -e "${GREEN}✓${NC} File exists: $1"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}✗${NC} File missing: $1"
        ((TESTS_FAILED++))
        return 1
    fi
}

assert_file_not_exists() {
    if [ ! -f "$1" ]; then
        echo -e "${GREEN}✓${NC} File correctly not exists: $1"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}✗${NC} File should not exist: $1"
        ((TESTS_FAILED++))
        return 1
    fi
}

assert_contains() {
    local file="$1"
    local pattern="$2"
    if grep -q "$pattern" "$file" 2>/dev/null; then
        echo -e "${GREEN}✓${NC} File contains '$pattern': $file"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}✗${NC} File missing '$pattern': $file"
        ((TESTS_FAILED++))
        return 1
    fi
}

assert_not_contains() {
    local file="$1"
    local pattern="$2"
    if ! grep -q "$pattern" "$file" 2>/dev/null; then
        echo -e "${GREEN}✓${NC} File correctly missing '$pattern': $file"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}✗${NC} File should not contain '$pattern': $file"
        ((TESTS_FAILED++))
        return 1
    fi
}

assert_executable() {
    if [ -x "$1" ]; then
        echo -e "${GREEN}✓${NC} File is executable: $1"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}✗${NC} File not executable: $1"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Setup test environment
setup_test_env() {
    echo "Setting up test environment..."
    mkdir -p "$TEST_BIN" "$TEST_CONFIG"
    export XDG_CONFIG_HOME="$TEST_DIR"
    
    # Create mock flatpak command
    cat > "$TEST_BIN/flatpak" << 'EOF'
#!/bin/bash
case "$1" in
    "list")
        if [[ "$*" == *"--app"* ]]; then
            echo "com.google.Chrome"
            echo "org.mozilla.Firefox"
            echo "com.visualstudio.code"
            echo "org.gnome.gedit"
        fi
        ;;
    "info")
        echo "ID: ${@: -1}"
        echo "Ref: app/${@: -1}/x86_64/stable"
        ;;
    "run")
        echo "Mock flatpak run: $*"
        ;;
    *)
        echo "Mock flatpak: $*"
        ;;
esac
EOF
    chmod +x "$TEST_BIN/flatpak"
    export PATH="$TEST_BIN:$PATH"
}

# Test 1: Basic wrapper generation
test_basic_generation() {
    echo -e "\n${YELLOW}Test 1: Basic wrapper generation${NC}"
    
    # Create simplified version of fplaunch-generate for testing
    cat > "$TEST_BIN/test-generate" << 'GENEOF'
#!/usr/bin/env bash
BIN_DIR="${1:-$HOME/bin}"
mkdir -p "$BIN_DIR"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/flatpak-wrappers"
mkdir -p "$CONFIG_DIR"

installed_ids="com.google.Chrome
org.mozilla.Firefox"

declare -A wrapper_names
while read -r id; do
    [ -z "$id" ] && continue
    name=$(echo "$id" | awk -F. '{print tolower($NF)}')
    [ -z "$name" ] && continue
    wrapper_names[$name]=$id
    
    cat > "$BIN_DIR/$name" << EOF
#!/usr/bin/env bash
# Generated by fplaunchwrapper
NAME="$name"
ID="$id"
echo "Running \$ID"
EOF
    chmod +x "$BIN_DIR/$name"
    echo "Created wrapper: $name"
done < <(echo "$installed_ids")
GENEOF
    chmod +x "$TEST_BIN/test-generate"
    
    # Run generator
    "$TEST_BIN/test-generate" "$TEST_BIN"
    
    # Verify wrappers created
    assert_file_exists "$TEST_BIN/chrome"
    assert_file_exists "$TEST_BIN/firefox"
    assert_executable "$TEST_BIN/chrome"
    assert_executable "$TEST_BIN/firefox"
    assert_contains "$TEST_BIN/chrome" "com.google.Chrome"
    assert_contains "$TEST_BIN/firefox" "org.mozilla.Firefox"
}

# Test 2: Collision detection
test_collision_detection() {
    echo -e "\n${YELLOW}Test 2: Collision detection${NC}"
    
    cat > "$TEST_BIN/test-collision" << 'GENEOF'
#!/usr/bin/env bash
BIN_DIR="$1"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/flatpak-wrappers"
mkdir -p "$CONFIG_DIR"

installed_ids="com.visualstudio.code
com.microsoft.code
org.example.code"

declare -A wrapper_names
declare -A collision_log
while read -r id; do
    [ -z "$id" ] && continue
    name=$(echo "$id" | awk -F. '{print tolower($NF)}')
    [ -z "$name" ] && continue
    
    if [ -n "${wrapper_names[$name]}" ]; then
        echo "COLLISION: $name (${wrapper_names[$name]} vs $id)"
        collision_log[$name]="${collision_log[$name]} $id"
        continue
    fi
    
    wrapper_names[$name]=$id
    cat > "$BIN_DIR/$name" << EOF
#!/usr/bin/env bash
# Generated by fplaunchwrapper
ID="$id"
EOF
    chmod +x "$BIN_DIR/$name"
done < <(echo "$installed_ids")

if [ ${#collision_log[@]} -gt 0 ]; then
    echo "Collisions detected: ${#collision_log[@]}"
fi
GENEOF
    chmod +x "$TEST_BIN/test-collision"
    
    output=$("$TEST_BIN/test-collision" "$TEST_BIN" 2>&1)
    
    # Should only create one 'code' wrapper
    assert_file_exists "$TEST_BIN/code"
    assert_contains "$TEST_BIN/code" "com.visualstudio.code"
    assert_not_contains "$TEST_BIN/code" "com.microsoft.code"
    
    # Check collision was detected
    if echo "$output" | grep -q "COLLISION"; then
        echo -e "${GREEN}✓${NC} Collision properly detected"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}✗${NC} Collision not detected"
        ((TESTS_FAILED++))
    fi
}

# Test 3: Blocklist functionality
test_blocklist() {
    echo -e "\n${YELLOW}Test 3: Blocklist functionality${NC}"
    
    # Clean up previous test wrappers
    rm -f "$TEST_BIN/chrome" "$TEST_BIN/firefox" "$TEST_BIN"/test-*
    
    mkdir -p "$TEST_CONFIG/flatpak-wrappers"
    echo "org.mozilla.Firefox" > "$TEST_CONFIG/flatpak-wrappers/blocklist"
    
    cat > "$TEST_BIN/test-blocklist" << 'GENEOF'
#!/usr/bin/env bash
BIN_DIR="$1"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/flatpak-wrappers"
BLOCKLIST="$CONFIG_DIR/blocklist"

installed_ids="com.google.Chrome
org.mozilla.Firefox"

while read -r id; do
    [ -z "$id" ] && continue
    
    if grep -q "^$id$" "$BLOCKLIST" 2>/dev/null; then
        echo "Skipping blocked: $id"
        continue
    fi
    
    name=$(echo "$id" | awk -F. '{print tolower($NF)}')
    cat > "$BIN_DIR/$name" << EOF
#!/usr/bin/env bash
ID="$id"
EOF
    chmod +x "$BIN_DIR/$name"
done < <(echo "$installed_ids")
GENEOF
    chmod +x "$TEST_BIN/test-blocklist"
    
    "$TEST_BIN/test-blocklist" "$TEST_BIN"
    
    # Chrome should exist, Firefox should not
    assert_file_exists "$TEST_BIN/chrome"
    assert_file_not_exists "$TEST_BIN/firefox"
}

# Test 4: Invalid name handling
test_invalid_names() {
    echo -e "\n${YELLOW}Test 4: Invalid name handling${NC}"
    
    cat > "$TEST_BIN/test-invalid" << 'GENEOF'
#!/usr/bin/env bash
BIN_DIR="$1"

invalid_ids="com.example.my@app
com.example.
com.example.valid-app
com.example.valid_app"

while read -r id; do
    [ -z "$id" ] && continue
    name=$(echo "$id" | awk -F. '{print tolower($NF)}')
    
    if [ -z "$name" ] || [[ "$name" =~ [^a-z0-9_\-] ]]; then
        echo "Skipping invalid: $id -> $name"
        continue
    fi
    
    cat > "$BIN_DIR/$name" << EOF
#!/usr/bin/env bash
ID="$id"
EOF
    chmod +x "$BIN_DIR/$name"
done < <(echo "$invalid_ids")
GENEOF
    chmod +x "$TEST_BIN/test-invalid"
    
    "$TEST_BIN/test-invalid" "$TEST_BIN"
    
    # Valid names should exist
    assert_file_exists "$TEST_BIN/valid-app"
    assert_file_exists "$TEST_BIN/valid_app"
    
    # Invalid should not exist
    assert_file_not_exists "$TEST_BIN/my@app"
}

# Test 5: Environment variable loading
test_env_loading() {
    echo -e "\n${YELLOW}Test 5: Environment variable loading${NC}"
    
    mkdir -p "$TEST_CONFIG/flatpak-wrappers"
    cat > "$TEST_CONFIG/flatpak-wrappers/testapp.env" << 'EOF'
export TEST_VAR="test_value"
export ANOTHER_VAR="another_value"
EOF
    
    cat > "$TEST_BIN/testapp" << 'EOF'
#!/usr/bin/env bash
NAME="testapp"
PREF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/flatpak-wrappers"

load_env_vars() {
    ENV_FILE="$PREF_DIR/$NAME.env"
    if [ -f "$ENV_FILE" ]; then
        source "$ENV_FILE"
    fi
}

load_env_vars
echo "TEST_VAR=$TEST_VAR"
echo "ANOTHER_VAR=$ANOTHER_VAR"
EOF
    chmod +x "$TEST_BIN/testapp"
    
    output=$("$TEST_BIN/testapp")
    
    if echo "$output" | grep -q "TEST_VAR=test_value"; then
        echo -e "${GREEN}✓${NC} Environment variable loaded"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}✗${NC} Environment variable not loaded"
        ((TESTS_FAILED++))
    fi
}

# Test 6: Pre-launch script execution
test_pre_launch_script() {
    echo -e "\n${YELLOW}Test 6: Pre-launch script execution${NC}"
    
    mkdir -p "$TEST_CONFIG/flatpak-wrappers/scripts/testapp"
    cat > "$TEST_CONFIG/flatpak-wrappers/scripts/testapp/pre-launch.sh" << 'EOF'
#!/usr/bin/env bash
echo "PRE_LAUNCH_EXECUTED"
echo "Args: $@" > /tmp/pre-launch-args-$$
EOF
    chmod +x "$TEST_CONFIG/flatpak-wrappers/scripts/testapp/pre-launch.sh"
    
    cat > "$TEST_BIN/testapp2" << 'EOF'
#!/usr/bin/env bash
NAME="testapp"
PREF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/flatpak-wrappers"

run_pre_launch_script() {
    PRE_LAUNCH_SCRIPT="$PREF_DIR/scripts/$NAME/pre-launch.sh"
    if [ -f "$PRE_LAUNCH_SCRIPT" ] && [ -x "$PRE_LAUNCH_SCRIPT" ]; then
        "$PRE_LAUNCH_SCRIPT" "$NAME" "$@"
    fi
}

run_pre_launch_script "arg1" "arg2"
echo "APP_EXECUTED"
EOF
    chmod +x "$TEST_BIN/testapp2"
    
    output=$("$TEST_BIN/testapp2")
    
    if echo "$output" | grep -q "PRE_LAUNCH_EXECUTED"; then
        echo -e "${GREEN}✓${NC} Pre-launch script executed"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}✗${NC} Pre-launch script not executed"
        ((TESTS_FAILED++))
    fi
}

# Test 7: Preference handling
test_preference_handling() {
    echo -e "\n${YELLOW}Test 7: Preference handling${NC}"
    
    mkdir -p "$TEST_CONFIG/flatpak-wrappers"
    echo "flatpak" > "$TEST_CONFIG/flatpak-wrappers/testapp.pref"
    
    cat > "$TEST_BIN/testapp3" << 'EOF'
#!/usr/bin/env bash
NAME="testapp"
PREF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/flatpak-wrappers"
PREF_FILE="$PREF_DIR/$NAME.pref"

if [ -f "$PREF_FILE" ]; then
    PREF=$(cat "$PREF_FILE")
    echo "Preference: $PREF"
else
    echo "No preference"
fi
EOF
    chmod +x "$TEST_BIN/testapp3"
    
    output=$("$TEST_BIN/testapp3")
    
    if echo "$output" | grep -q "Preference: flatpak"; then
        echo -e "${GREEN}✓${NC} Preference loaded correctly"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}✗${NC} Preference not loaded"
        ((TESTS_FAILED++))
    fi
}

# Test 8: Wrapper cleanup
test_wrapper_cleanup() {
    echo -e "\n${YELLOW}Test 8: Wrapper cleanup for uninstalled apps${NC}"
    
    # Create wrapper for app that's no longer installed
    cat > "$TEST_BIN/oldapp" << 'EOF'
#!/usr/bin/env bash
# Generated by fplaunchwrapper
ID="com.example.OldApp"
EOF
    chmod +x "$TEST_BIN/oldapp"
    
    cat > "$TEST_BIN/test-cleanup" << 'GENEOF'
#!/usr/bin/env bash
BIN_DIR="$1"
installed_ids="com.google.Chrome"

# Get existing wrappers
for script in "$BIN_DIR"/*; do
    if [ -f "$script" ] && grep -q "Generated by fplaunchwrapper" "$script"; then
        id=$(grep '^ID=' "$script" | cut -d'"' -f2)
        if [ -n "$id" ] && ! echo "$installed_ids" | grep -q "^$id$"; then
            echo "Removing obsolete: $(basename "$script")"
            rm "$script"
        fi
    fi
done
GENEOF
    chmod +x "$TEST_BIN/test-cleanup"
    
    assert_file_exists "$TEST_BIN/oldapp"
    "$TEST_BIN/test-cleanup" "$TEST_BIN"
    assert_file_not_exists "$TEST_BIN/oldapp"
}

# Test 9: Tar extraction safety
test_tar_safety() {
    echo -e "\n${YELLOW}Test 9: Tar extraction safety${NC}"
    
    # Create safe archive
    mkdir -p "$TEST_DIR/safe"
    echo "test" > "$TEST_DIR/safe/prefs"
    tar -czf "$TEST_DIR/safe.tar.gz" -C "$TEST_DIR/safe" prefs
    
    # Create malicious archive with path traversal
    mkdir -p "$TEST_DIR/malicious"
    echo "malicious" > "$TEST_DIR/malicious/passwd"
    # Use --transform to create a path traversal in the archive
    tar -czf "$TEST_DIR/malicious.tar.gz" -C "$TEST_DIR/malicious" --transform='s,^,../../etc/,' passwd 2>/dev/null || {
        # Fallback: create archive manually with dangerous path
        mkdir -p "$TEST_DIR/maltemp"
        echo "malicious" > "$TEST_DIR/maltemp/passwd"
        (cd "$TEST_DIR/maltemp" && tar -czf "../malicious.tar.gz" --transform='s|passwd|../../etc/passwd|' passwd 2>/dev/null) || \
        tar -czf "$TEST_DIR/malicious.tar.gz" -C "$TEST_DIR/maltemp" passwd
    }
    
    cat > "$TEST_BIN/test-tar-import" << 'EOF'
#!/usr/bin/env bash
import_safe() {
    file="$1"
    dest="$2"
    if tar -tzf "$file" 2>/dev/null | grep -q '\.\.'; then
        echo "REJECTED: Path traversal detected"
        return 1
    else
        tar -xzf "$file" -C "$dest" 2>/dev/null
        echo "ACCEPTED: Safe extraction"
        return 0
    fi
}

import_safe "$1" "$2"
EOF
    chmod +x "$TEST_BIN/test-tar-import"
    
    # Test safe archive
    mkdir -p "$TEST_DIR/extract-safe"
    output=$("$TEST_BIN/test-tar-import" "$TEST_DIR/safe.tar.gz" "$TEST_DIR/extract-safe" 2>&1)
    if echo "$output" | grep -q "ACCEPTED"; then
        echo -e "${GREEN}✓${NC} Safe archive accepted"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}✗${NC} Safe archive rejected"
        ((TESTS_FAILED++))
    fi
    
    # Test malicious archive
    mkdir -p "$TEST_DIR/extract-malicious"
    output=$("$TEST_BIN/test-tar-import" "$TEST_DIR/malicious.tar.gz" "$TEST_DIR/extract-malicious" 2>&1)
    if echo "$output" | grep -q "REJECTED"; then
        echo -e "${GREEN}✓${NC} Malicious archive rejected"
        ((TESTS_PASSED++))
    else
        echo -e "${RED}✗${NC} Malicious archive not rejected"
        ((TESTS_FAILED++))
    fi
}

# Test 10: System command detection
test_system_command_detection() {
    echo -e "\n${YELLOW}Test 10: System command detection${NC}"
    
    # Create mock system command
    mkdir -p "$TEST_DIR/usr/bin"
    cat > "$TEST_DIR/usr/bin/testcmd" << 'EOF'
#!/bin/bash
echo "System command"
EOF
    chmod +x "$TEST_DIR/usr/bin/testcmd"
    
    cat > "$TEST_BIN/test-system-detect" << 'EOF'
#!/usr/bin/env bash
NAME="testcmd"
SCRIPT_BIN_DIR="$1"
SYSTEM_EXISTS=false

for sys_dir in "/usr/local/bin" "/usr/bin" "/bin"; do
    candidate="$sys_dir/$NAME"
    if [ -f "$candidate" ] && [ -x "$candidate" ] && [ "$candidate" != "$SCRIPT_BIN_DIR/$NAME" ]; then
        SYSTEM_EXISTS=true
        break
    fi
done

echo "System exists: $SYSTEM_EXISTS"
EOF
    chmod +x "$TEST_BIN/test-system-detect"
    
    output=$("$TEST_BIN/test-system-detect" "$TEST_BIN")
    
    if echo "$output" | grep -q "System exists: true"; then
        echo -e "${GREEN}✓${NC} System command detected"
        ((TESTS_PASSED++))
    else
        # This is expected if /usr/bin/testcmd doesn't exist in actual system
        echo -e "${YELLOW}~${NC} System command detection (skipped - no real system command)"
    fi
}

# Run all tests
main() {
    echo "======================================"
    echo "Flatpak Wrapper Test Suite"
    echo "======================================"
    
    setup_test_env
    
    test_basic_generation
    test_collision_detection
    test_blocklist
    test_invalid_names
    test_env_loading
    test_pre_launch_script
    test_preference_handling
    test_wrapper_cleanup
    test_tar_safety
    test_system_command_detection
    
    echo ""
    echo "======================================"
    echo "Test Results"
    echo "======================================"
    echo -e "${GREEN}Passed: $TESTS_PASSED${NC}"
    echo -e "${RED}Failed: $TESTS_FAILED${NC}"
    echo "Total:  $((TESTS_PASSED + TESTS_FAILED))"
    echo "======================================"
    
    if [ $TESTS_FAILED -eq 0 ]; then
        echo -e "${GREEN}All tests passed!${NC}"
        exit 0
    else
        echo -e "${RED}Some tests failed!${NC}"
        exit 1
    fi
}

main "$@"
