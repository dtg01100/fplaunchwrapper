#!/usr/bin/env python3
"""Comprehensive test suite for fplaunchwrapper using pytest
Tests all core functionality with proper mocking and fixtures.
"""

import os
import subprocess
import tempfile
from pathlib import Path
from unittest.mock import patch

import pytest

try:
    from lib.python_utils import (
        canonicalize_path_no_resolve,
        find_executable,
        get_wrapper_id,
        is_wrapper_file,
        safe_mktemp,
        sanitize_id_to_name,
        sanitize_string,
        validate_home_dir,
    )
except ImportError:
    # Fallback for when modules aren't available
    sanitize_string = canonicalize_path_no_resolve = validate_home_dir = None
    is_wrapper_file = get_wrapper_id = sanitize_id_to_name = None
    find_executable = safe_mktemp = None


class TestPythonUtils:
    """Test python utility functions."""

    def test_sanitize_string_basic(self) -> None:
        """Test basic string sanitization."""
        if not sanitize_string:
            pytest.skip("python_utils not available")

        result = sanitize_string("test")
        assert result == "test"

    def test_sanitize_string_injection(self) -> None:
        """Test string sanitization against injection attacks."""
        if not sanitize_string:
            pytest.skip("python_utils not available")

        malicious = '"; rm -rf / #'
        result = sanitize_string(malicious)
        # The function escapes dangerous characters, not removes them
        assert result == '\\"\\; rm -rf / #'  # Should be escaped
        assert '"' not in result.replace('\\"', "")  # No unescaped quotes
        assert ";" not in result.replace("\\;", "")  # No unescaped semicolons

    def test_canonicalize_path_basic(self) -> None:
        """Test basic path canonicalization."""
        if not canonicalize_path_no_resolve:
            pytest.skip("python_utils not available")

        with tempfile.TemporaryDirectory() as tmpdir:
            test_path = os.path.join(tmpdir, "test")
            result = canonicalize_path_no_resolve(test_path)
            assert result == Path(test_path)

    def test_canonicalize_path_relative(self) -> None:
        """Test relative path canonicalization."""
        if not canonicalize_path_no_resolve:
            pytest.skip("python_utils not available")

        # Change to temp directory for relative path test
        original_cwd = os.getcwd()
        with tempfile.TemporaryDirectory() as tmpdir:
            os.chdir(tmpdir)
            try:
                result = canonicalize_path_no_resolve("../test")
                expected = Path(os.path.abspath("../test"))
                assert result == expected
            finally:
                os.chdir(original_cwd)

    def test_validate_home_dir_valid(self) -> None:
        """Test home directory validation with valid path."""
        if not validate_home_dir:
            pytest.skip("python_utils not available")

        # Test with a path under home
        home_subdir = os.path.join(os.path.expanduser("~"), "test")
        result = validate_home_dir(home_subdir)
        assert result == home_subdir

    def test_validate_home_dir_invalid(self) -> None:
        """Test home directory validation with invalid path."""
        if not validate_home_dir:
            pytest.skip("python_utils not available")

        # Test with system path
        result = validate_home_dir("/usr/bin")
        assert result is None

    def test_is_wrapper_file_valid(self) -> None:
        """Test wrapper file validation with valid wrapper."""
        if not is_wrapper_file:
            pytest.skip("python_utils not available")

        with tempfile.NamedTemporaryFile(mode="w", suffix=".sh", delete=False) as f:
            f.write("#!/usr/bin/env bash\n")
            f.write("# Generated by fplaunchwrapper\n")
            f.write('NAME="test"\n')
            f.write('ID="org.test.app"\n')
            f.write('flatpak run "$ID" "$@"\n')
            temp_path = f.name

        try:
            result = is_wrapper_file(temp_path)
            assert result is True
        finally:
            os.unlink(temp_path)

    def test_is_wrapper_file_invalid(self) -> None:
        """Test wrapper file validation with invalid file."""
        if not is_wrapper_file:
            pytest.skip("python_utils not available")

        # Test file without proper shebang
        with tempfile.NamedTemporaryFile(mode="w", delete=False) as f:
            f.write("#!/bin/python3\n")  # Wrong interpreter
            f.write("# Generated by fplaunchwrapper\n")
            f.write('NAME="test"\n')
            f.write('ID="org.test.app"\n')
            f.write('flatpak run "$ID" "$@"\n')
            temp_path = f.name

        try:
            result = is_wrapper_file(temp_path)
            assert result is False
        finally:
            os.unlink(temp_path)

    def test_get_wrapper_id(self) -> None:
        """Test wrapper ID extraction."""
        if not get_wrapper_id:
            pytest.skip("python_utils not available")

        with tempfile.NamedTemporaryFile(mode="w", suffix=".sh", delete=False) as f:
            f.write("#!/usr/bin/env bash\n")
            f.write("# Generated by fplaunchwrapper\n")
            f.write("NAME=test\n")
            f.write('ID="org.test.app"\n')
            f.write('flatpak run org.test.app "$@"\n')
            temp_path = f.name

        try:
            result = get_wrapper_id(temp_path)
            assert result == "org.test.app"
        finally:
            os.unlink(temp_path)

    @pytest.mark.parametrize(
        ("input_id", "expected"),
        [
            ("org.mozilla.firefox", "firefox"),
            ("com.example.Test-App_1.2.3", "3"),  # Last component after dots
            ("org.gimp.GIMP", "gimp"),
            ("com.valvesoftware.Steam", "steam"),
        ],
    )
    def test_sanitize_id_to_name(self, input_id, expected) -> None:
        """Test ID to name sanitization."""
        if not sanitize_id_to_name:
            pytest.skip("python_utils not available")

        result = sanitize_id_to_name(input_id)
        assert result == expected

    def test_find_executable_bash(self) -> None:
        """Test finding bash executable."""
        if not find_executable:
            pytest.skip("python_utils not available")

        result = find_executable("bash")
        assert result is not None
        assert "bash" in result

    def test_find_executable_nonexistent(self) -> None:
        """Test finding non-existent executable."""
        if not find_executable:
            pytest.skip("python_utils not available")

        result = find_executable("nonexistent_command_xyz")
        assert result is None

    def test_safe_mktemp_basic(self) -> None:
        """Test secure temporary file creation."""
        if not safe_mktemp:
            pytest.skip("python_utils not available")

        result = safe_mktemp()
        assert result is not None
        assert os.path.exists(result)
        assert os.access(result, os.W_OK)

        # Clean up
        os.unlink(result)

    def test_safe_mktemp_custom_template(self) -> None:
        """Test temp file creation with custom template."""
        if not safe_mktemp:
            pytest.skip("python_utils not available")

        result = safe_mktemp("test-XXXXXX.txt")
        assert result is not None
        assert result.endswith(".txt")
        assert "test-" in result

        # Clean up
        os.unlink(result)


class TestBashIntegration:
    """Test integration with bash scripts."""

    @pytest.fixture
    def temp_bin_dir(self, tmp_path):
        """Create temporary bin directory."""
        bin_dir = tmp_path / "bin"
        bin_dir.mkdir()
        return bin_dir

    @pytest.fixture
    def temp_config_dir(self, tmp_path):
        """Create temporary config directory."""
        config_dir = tmp_path / "config"
        config_dir.mkdir()
        return config_dir

    def test_bash_script_execution(self, temp_bin_dir) -> None:
        """Test basic bash script execution."""
        script_path = temp_bin_dir / "test_script.sh"
        script_path.write_text(
            """#!/bin/bash
echo "Hello from bash script"
exit 0
"""
        )
        script_path.chmod(0o755)

        result = subprocess.run(
            [str(script_path)], check=False, capture_output=True, text=True
        )
        assert result.returncode == 0
        assert "Hello from bash script" in result.stdout

    def test_wrapper_script_generation(self, temp_bin_dir, temp_config_dir) -> None:
        """Test wrapper script generation logic."""
        # Mock flatpak list output

        # This would test the actual generation script
        # For now, just verify the directories exist
        assert temp_bin_dir.exists()
        assert temp_config_dir.exists()

    @patch("subprocess.run")
    def test_flatpak_command_mocking(self, mock_run, temp_bin_dir) -> None:
        """Test flatpak command execution with mocking."""
        mock_run.return_value.returncode = 0
        mock_run.return_value.stdout = "org.mozilla.firefox"

        # Simulate calling flatpak list
        result = mock_run(["flatpak", "list", "--app"])

        mock_run.assert_called_once_with(["flatpak", "list", "--app"])
        assert result.returncode == 0


class TestSecurity:
    """Security-focused tests."""

    def test_path_traversal_prevention(self) -> None:
        """Test prevention of path traversal attacks."""
        if not validate_home_dir:
            pytest.skip("python_utils not available")

        attack_paths = [
            "../../../etc/passwd",
            "~/../etc/passwd",
            "/dev/null/../etc/passwd",
        ]

        for attack_path in attack_paths:
            result = validate_home_dir(attack_path)
            # Should return None for paths outside HOME
            assert result is None

    def test_command_injection_prevention(self) -> None:
        """Test prevention of command injection."""
        if not sanitize_string:
            pytest.skip("python_utils not available")

        injection_attempts = [
            '"; rm -rf / #',
            "$(rm -rf /)",
            "`rm -rf /`",
            "${rm,-rf,/}",
            "test$(echo pwned)",
            "test`echo pwned`",
        ]

        for injection in injection_attempts:
            result = sanitize_string(injection)
            # Ensure dangerous characters are properly escaped (not executable)
            assert ";" not in result.replace("\\;", "")  # No unescaped semicolons
            assert "$" not in result.replace("\\$", "")  # No unescaped dollar signs
            assert "`" not in result.replace("\\`", "")  # No unescaped backticks
            assert "(" not in result.replace("\\(", "")  # No unescaped parentheses
            assert ")" not in result.replace("\\)", "")  # No unescaped parentheses

    def test_file_validation_security(self) -> None:
        """Test file validation prevents malicious files."""
        if not is_wrapper_file:
            pytest.skip("python_utils not available")

        # Test with binary file
        with tempfile.NamedTemporaryFile(delete=False) as f:
            f.write(b"\x00\x01\x02\x03\x04\x05")  # Binary content
            binary_path = f.name

        try:
            result = is_wrapper_file(binary_path)
            assert result is False
        finally:
            os.unlink(binary_path)

    def test_symlink_attack_prevention(self) -> None:
        """Test prevention of symlink attacks."""
        if not is_wrapper_file:
            pytest.skip("python_utils not available")

        with tempfile.TemporaryDirectory() as tmpdir:
            # Create a symlink to a sensitive file
            sensitive_file = "/etc/passwd"
            symlink_path = os.path.join(tmpdir, "malicious_wrapper")

            try:
                os.symlink(sensitive_file, symlink_path)
                result = is_wrapper_file(symlink_path)
                assert result is False  # Should reject symlinks
            except OSError:
                # Symlink creation might fail in some environments
                pytest.skip("Cannot create symlinks in test environment")


class TestPerformance:
    """Performance-focused tests."""

    def test_sanitization_performance(self) -> None:
        """Test sanitization performance with large inputs."""
        if not sanitize_string:
            pytest.skip("python_utils not available")

        large_input = "test" * 10000  # 40KB string
        import time

        start_time = time.time()
        result = sanitize_string(large_input)
        end_time = time.time()

        # Should complete in reasonable time (< 1 second)
        assert end_time - start_time < 1.0
        assert len(result) > 0

    def test_path_operations_performance(self) -> None:
        """Test path operations performance."""
        if not canonicalize_path_no_resolve:
            pytest.skip("python_utils not available")

        import time

        test_paths = [
            "/tmp/test",
            "../relative/path",
            "~/user/path",
            "/very/long/path/with/many/components/that/should/be/canonicalized",
        ] * 100

        start_time = time.time()
        for path in test_paths:
            result = canonicalize_path_no_resolve(path)
            assert result is not None
        end_time = time.time()

        # Should complete in reasonable time (< 2 seconds for 400 operations)
        assert end_time - start_time < 2.0


class TestConfiguration:
    """Test configuration management."""

    def test_config_manager_creation(self) -> None:
        """Test configuration manager creation."""
        try:
            from lib.config_manager import create_config_manager
        except ImportError:
            pytest.skip("config_manager not available")

        config = create_config_manager()
        assert config is not None
        assert hasattr(config, "config")
        assert hasattr(config.config, "bin_dir")

    def test_config_file_operations(self) -> None:
        """Test configuration file read/write."""
        try:
            from lib.config_manager import create_config_manager
        except ImportError:
            pytest.skip("config_manager not available")

        config = create_config_manager()

        # Test basic configuration
        assert config.config.bin_dir != ""
        assert isinstance(config.config.debug_mode, bool)


if __name__ == "__main__":
    # Run tests if called directly
    pytest.main([__file__, "-v"])
