#!/usr/bin/env bash
# Aggressive integration tests - testing complete workflows under attack
# Self-contained end-to-end testing designed to break the system

# Developer workstation safety check - never run as root
if [ "$(id -u)" = "0" ] && ! is_ci && [ "${TESTING:-}" != "1" ]; then
    echo "ERROR: Refusing to run tests as root for safety"
    echo "This project should never be run with root privileges"
    exit 1
fi

# Set testing environment
export TESTING=1
export CI=1

TEST_DIR="/tmp/fplaunch-integration-test-$$"
# shellcheck disable=SC2034  # SCRIPT_DIR kept for potential future use
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
# shellcheck disable=SC2034
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m'

TESTS_PASSED=0
TESTS_FAILED=0

cleanup() {
    rm -rf "$TEST_DIR"
}
trap cleanup EXIT

log_test() {
    echo -e "${BLUE}[TEST]${NC} $1"
}

log_pass() {
    echo -e "${GREEN}✓${NC} $1"
    ((TESTS_PASSED++))
}

log_fail() {
    echo -e "${RED}✗${NC} $1 - SYSTEM COMPROMISED!"
    ((TESTS_FAILED++))
}

log_attack() {
    echo -e "${PURPLE}[ATTACK]${NC} $1"
}

log_defense() {
    echo -e "${GREEN}[DEFENSE]${NC} $1"
}

# Aggressive Integration Test 2: Multi-user and concurrent workflow testing
# WHAT IT TESTS: System behavior under concurrent access and multi-user scenarios
# WHY IT MATTERS: Real deployments involve multiple users and concurrent operations
# CONCURRENT SCENARIOS TESTED:
# - Multiple users creating wrappers simultaneously
# - Concurrent preference modifications
# - Race conditions in file operations
# - Lock contention and deadlocks
# - Data consistency across concurrent operations
# - Resource sharing and isolation
test_aggressive_concurrent_workflows() {
    log_test "Multi-user and concurrent workflow testing under attack conditions"
    echo "Testing system behavior under concurrent access and multi-user scenarios..."
    
    local concurrent_tests_passed=0
    local total_concurrent_tests=0
    
    # Concurrent Test 1: Multiple simultaneous wrapper creation
    log_attack "Multiple users creating wrappers simultaneously"
    ((total_concurrent_tests++))
    
    local concurrent_users=5
    local wrapper_creation_pids=()
    
    # Launch multiple wrapper creation processes
    for user_id in $(seq 1 $concurrent_users); do
        (
            local user_test_dir="/tmp/concurrent_user_${user_id}_$$"
            mkdir -p "$user_test_dir/bin" "$user_test_dir/config"
            
            # Simulate wrapper creation
            for i in {1..10}; do
                cat > "$user_test_dir/bin/app_${user_id}_${i}" << EOF
#!/usr/bin/env bash
# Generated by fplaunchwrapper
NAME="app_${user_id}_${i}"
ID="com.example.App${user_id}${i}"
echo "User $user_id, App $i"
EOF
                chmod +x "$user_test_dir/bin/app_${user_id}_${i}"
            done
            
            # Count created wrappers
            local created_wrappers
            created_wrappers=$(find "$user_test_dir/bin" -name "app_${user_id}_*" | wc -l)
            echo "User $user_id created $created_wrappers wrappers"
        ) &
        
        wrapper_creation_pids+=($!)
    done
    
    # Wait for all processes and check results
    local all_completed=true
    for pid in "${wrapper_creation_pids[@]}"; do
        if ! wait "$pid"; then
            all_completed=false
        fi
    done
    
    if [ "$all_completed" = true ]; then
        log_defense "Concurrent wrapper creation successful - no conflicts detected"
        ((concurrent_tests_passed++))
    else
        log_fail "Concurrent wrapper creation failed - race conditions detected"
    fi
    
    # Concurrent Test 2: Simultaneous preference modifications
    log_attack "Simultaneous preference modifications"
    ((total_concurrent_tests++))
    
    local pref_test_file="/tmp/concurrent_pref_test_$$"
    echo "initial_value" > "$pref_test_file"
    
    local preference_modification_pids=()
    
    # Launch multiple preference modification processes
    for process_id in {1..5}; do
        (
            for iteration in {1..20}; do
                # Read current value
                local current_value
                # shellcheck disable=SC2034
                current_value=$(cat "$pref_test_file" 2>/dev/null || echo "error")
                
                # Modify value
                local new_value="process_${process_id}_iteration_${iteration}"
                echo "$new_value" > "$pref_test_file"
                
                # Verify write succeeded
                local verify_value
                verify_value=$(cat "$pref_test_file" 2>/dev/null || echo "error")
                
                if [ "$verify_value" != "$new_value" ]; then
                    echo "CONCURRENT_WRITE_ERROR: Expected $new_value, got $verify_value"
                    exit 1
                fi
                
                # Small delay to increase contention
                sleep 0.01
            done
            echo "Process $process_id completed successfully"
        ) &
        
        preference_modification_pids+=($!)
    done
    
    # Wait for all preference modification processes
    local pref_modifications_successful=true
    for pid in "${preference_modification_pids[@]}"; do
        if ! wait "$pid"; then
            pref_modifications_successful=false
        fi
    done
    
    if [ "$pref_modifications_successful" = true ]; then
        log_defense "Concurrent preference modifications successful - no data corruption"
        ((concurrent_tests_passed++))
    else
        log_fail "Concurrent preference modifications failed - data corruption detected"
    fi
    
    # Concurrent Test 3: File system race conditions
    log_attack "File system race condition testing"
    ((total_concurrent_tests++))
    
    local race_test_dir="/tmp/race_test_$$"
    mkdir -p "$race_test_dir"
    
    local race_condition_pids=()
    local race_errors=0
    
    # Create multiple processes that rapidly create and delete files
    for race_process in {1..3}; do
        (
            for race_iteration in {1..50}; do
                local test_file="$race_test_dir/race_${race_process}_${race_iteration}"
                
                # Create file
                echo "process_${race_process}_iteration_${race_iteration}" > "$test_file"
                
                # Verify file exists and has correct content
                if [ ! -f "$test_file" ]; then
                    echo "RACE_ERROR: File $test_file does not exist"
                    exit 1
                fi
                
                local file_content
                file_content=$(cat "$test_file" 2>/dev/null || echo "")
                if [[ "$file_content" != "process_${race_process}_iteration_${race_iteration}" ]]; then
                    echo "RACE_ERROR: File $test_file has incorrect content: $file_content"
                    exit 1
                fi
                
                # Delete file
                rm -f "$test_file"
                
                # Verify file is gone
                if [ -f "$test_file" ]; then
                    echo "RACE_ERROR: File $test_file still exists after deletion"
                    exit 1
                fi
                
                # Small random delay
                sleep 0.001
            done
            echo "Race process $race_process completed successfully"
        ) &
        
        race_condition_pids+=($!)
    done
    
    # Wait for all race condition processes
    for pid in "${race_condition_pids[@]}"; do
        if ! wait "$pid"; then
            race_errors=$((race_errors + 1))
        fi
    done
    
    if [ $race_errors -eq 0 ]; then
        log_defense "Race condition testing passed - no file system corruption"
        ((concurrent_tests_passed++))
    else
        log_fail "Race condition testing failed - $race_errors race condition errors detected"
    fi
    
    # Concurrent Test 4: Resource contention testing
    log_attack "Resource contention and deadlock testing"
    ((total_concurrent_tests++))
    
    local resource_test_pids=()
    local deadlock_detected=false
    
    # Create processes that compete for resources
    for resource_process in {1..4}; do
        (
            # Simulate resource locking and usage
            local lock_file="/tmp/resource_lock_${resource_process}_$$"
            local max_attempts=10
            
            for attempt in $(seq 1 $max_attempts); do
                # Try to acquire lock (simulate with file locking)
                if (set -o noclobber; echo "$$" > "$lock_file") 2>/dev/null; then
                    # Lock acquired - perform critical section
                    echo "Process $resource_process acquired lock on attempt $attempt"
                    
                    # Simulate work in critical section
                    sleep 0.05
                    
                    # Release lock
                    rm -f "$lock_file"
                    break
                else
                    # Lock not available - wait and retry
                    sleep 0.02
                fi
                
                if [ $attempt -eq $max_attempts ]; then
                    echo "DEADLOCK_DETECTED: Process $resource_process failed to acquire lock after $max_attempts attempts"
                    exit 1
                fi
            done
            
            echo "Process $resource_process completed successfully"
        ) &
        
        resource_test_pids+=($!)
    done
    
    # Wait for resource contention processes with timeout
    local resource_timeout=10
    for pid in "${resource_test_pids[@]}"; do
        if ! timeout "$resource_timeout" wait "$pid"; then
            deadlock_detected=true
            log_fail "Deadlock detected in resource contention testing"
        fi
    done
    
    if [ "$deadlock_detected" = false ]; then
        log_defense "Resource contention testing passed - no deadlocks detected"
        ((concurrent_tests_passed++))
    fi
    
    # Results
    echo ""
    echo "Concurrent Testing Results:"
    echo "Concurrent tests passed: $concurrent_tests_passed/$total_concurrent_tests"
    
    if [ $concurrent_tests_passed -eq $total_concurrent_tests ]; then
        log_defense "ALL CONCURRENT TESTS PASSED - System handles concurrency well!"
    elif [ $concurrent_tests_passed -gt $((total_concurrent_tests * 3 / 4)) ]; then
        log_defense "Most concurrent tests passed ($concurrent_tests_passed/$total_concurrent_tests) - Good concurrency support!"
    else
        log_fail "Too many concurrent tests failed ($concurrent_tests_passed/$total_concurrent_tests) - CONCURRENCY ISSUES!"
    fi
    
    log_pass "Aggressive concurrent workflow testing completed"
}

# Integration Test 1: Complete wrapper lifecycle under attack conditions
test_complete_lifecycle() {
    log_test "Complete wrapper lifecycle under attack conditions"
    
    local test_bin="$TEST_DIR/bin"
    local test_config="$TEST_DIR/config"
    mkdir -p "$test_bin" "$test_config"
    
    # Step 1: Create wrapper (simulating fplaunch-generate behavior)
    cat > "$test_bin/myapp" << 'EOF'
#!/bin/bash
NAME="myapp"
ID="com.example.MyApp"
VERSION="1.0"
echo "Running $NAME version $VERSION"
EOF
    chmod +x "$test_bin/myapp"
    
    if [ -x "$test_bin/myapp" ]; then
        log_pass "Wrapper created and executable"
    else
        log_fail "Wrapper not created properly"
    fi
    
    # Step 2: Set preference
    echo "flatpak" > "$test_config/myapp.pref"
    if [ "$(cat "$test_config/myapp.pref")" = "flatpak" ]; then
        log_pass "Preference saved"
    else
        log_fail "Preference not saved"
    fi
    
    # Step 3: Update wrapper (version change)
    sed -i 's/VERSION="1.0"/VERSION="1.1"/' "$test_bin/myapp"
    if grep -q 'VERSION="1.1"' "$test_bin/myapp"; then
        log_pass "Wrapper updated"
    else
        log_fail "Wrapper update failed"
    fi
    
    # Step 4: Preference persists after update
    if [ "$(cat "$test_config/myapp.pref")" = "flatpak" ]; then
        log_pass "Preference persisted after update"
    else
        log_fail "Preference lost after update"
    fi
    
    # Step 5: Remove wrapper and cleanup
    rm "$test_bin/myapp"
    rm "$test_config/myapp.pref"
    
    if [ ! -f "$test_bin/myapp" ] && [ ! -f "$test_config/myapp.pref" ]; then
        log_pass "Wrapper and config removed"
    else
        log_fail "Cleanup incomplete"
    fi
}

# Integration Test 2: Multi-wrapper with collision
test_multi_wrapper_collision() {
    log_test "Multiple wrappers with name collision handling"
    
    local test_bin="$TEST_DIR/bin2"
    mkdir -p "$test_bin"
    
    # Simulate installing multiple apps
    declare -A wrapper_names
    local installed_ids="com.google.Chrome
org.chromium.Chromium
com.microsoft.edge
org.mozilla.Firefox
com.brave.Browser"
    
    local created=0
    local skipped=0
    
    while read -r id; do
        [ -z "$id" ] && continue
        name=$(echo "$id" | awk -F. '{print tolower($NF)}')
        
        if [ -n "${wrapper_names[$name]}" ]; then
            ((skipped++))
            continue
        fi
        
        wrapper_names[$name]=$id
cat > "$test_bin/$name" << 'WRAPPER_EOF'
#!/bin/bash
ID="$id"
WRAPPER_EOF
chmod +x "$test_bin/$name"
((created++))
done < <(echo "$installed_ids")
    
    if [ "$created" -eq 5 ] && [ "$skipped" -eq 0 ]; then
        log_pass "All 5 unique wrappers created"
    else
        log_fail "Expected 5 created, 0 skipped; got $created created, $skipped skipped"
    fi
    
    # Verify each wrapper exists
    for name in chrome chromium edge firefox browser; do
        if [ -f "$test_bin/$name" ]; then
            log_pass "Wrapper exists: $name"
        else
            log_fail "Wrapper missing: $name"
        fi
    done
}

# Integration Test 3: Preference override workflow
test_preference_override_workflow() {
    log_test "Preference override and fallback workflow"
    
    local test_config="$TEST_DIR/config3"
    mkdir -p "$test_config"
    
    # User chooses system
    echo "system" > "$test_config/editor.pref"
    log_pass "User chose 'system'"
    
    # Simulate system package removed (fallback to flatpak)
    pref=$(cat "$test_config/editor.pref")
    if [ "$pref" = "system" ]; then
        # System command gone, fallback
        echo "flatpak" > "$test_config/editor.pref"
        log_pass "Fallback to flatpak after system removed"
    fi
    
    # Verify new preference
    if [ "$(cat "$test_config/editor.pref")" = "flatpak" ]; then
        log_pass "Preference updated to flatpak"
    else
        log_fail "Preference not updated"
    fi
}

# Integration Test 4: Alias chain
test_alias_chain() {
    log_test "Alias creation and resolution"
    
    local test_bin="$TEST_DIR/bin4"
    local test_config="$TEST_DIR/config4"
    mkdir -p "$test_bin" "$test_config"
    
    # Create base wrapper
    cat > "$test_bin/chrome" << 'EOF'
#!/bin/bash
echo "Chrome wrapper"
EOF
    chmod +x "$test_bin/chrome"
    
    # Create aliases
    ln -s "$test_bin/chrome" "$test_bin/browser"
    ln -s "$test_bin/chrome" "$test_bin/web"
    
    echo "browser chrome" >> "$test_config/aliases"
    echo "web chrome" >> "$test_config/aliases"
    
    if [ -L "$test_bin/browser" ] && [ -L "$test_bin/web" ]; then
        log_pass "Aliases created"
    else
        log_fail "Aliases not created"
    fi
    
    # Verify aliases point to correct target
    if [ "$(readlink "$test_bin/browser")" = "$test_bin/chrome" ]; then
        log_pass "Alias 'browser' points to chrome"
    else
        log_fail "Alias 'browser' incorrect"
    fi
    
    # Test alias execution
    if [ -x "$test_bin/browser" ]; then
        if output=$("$test_bin/browser" 2>&1); then
            if echo "$output" | grep -q "Chrome wrapper"; then
                log_pass "Alias execution works"
            else
                log_fail "Alias execution failed - output: $output"
            fi
        else
            log_fail "Alias execution failed with error"
            # Return early to prevent potential issues
            return 1
        fi
    else
        log_fail "Alias file doesn't exist or isn't executable"
        # Return early to prevent potential issues
        return 1
    fi
}

# Integration Test 5: Environment and script combination
test_env_and_script_combo() {
    log_test "Environment variables + pre-launch script integration"
    
    local test_bin="$TEST_DIR/bin5"
    local test_config="$TEST_DIR/config5"
    mkdir -p "$test_bin" "$test_config/scripts/testapp"
    
    # Create env file
    cat > "$test_config/testapp.env" << 'EOF'
export MY_VAR="from_env"
export MY_PATH="/custom/path"
EOF
    
    # Create pre-launch script
    cat > "$test_config/scripts/testapp/pre-launch.sh" << 'EOF'
#!/bin/bash
echo "Pre-launch: MY_VAR=$MY_VAR"
echo "Pre-launch: MY_PATH=$MY_PATH"
EOF
    chmod +x "$test_config/scripts/testapp/pre-launch.sh"
    
    # Create wrapper that loads env and runs pre-launch
    cat > "$test_bin/testapp" << 'EOF'
#!/bin/bash
NAME="testapp"
CONFIG_DIR="${1:-/tmp}"

# Load env
ENV_FILE="$CONFIG_DIR/testapp.env"
if [ -f "$ENV_FILE" ]; then
    source "$ENV_FILE"
fi

# Run pre-launch
PRE_SCRIPT="$CONFIG_DIR/scripts/testapp/pre-launch.sh"
if [ -f "$PRE_SCRIPT" ] && [ -x "$PRE_SCRIPT" ]; then
    "$PRE_SCRIPT"
fi

echo "App: MY_VAR=$MY_VAR"
EOF
    chmod +x "$test_bin/testapp"
    
    output=$("$test_bin/testapp" "$test_config" 2>&1)
    
    if echo "$output" | grep -q "Pre-launch: MY_VAR=from_env"; then
        log_pass "Pre-launch script has access to environment variables"
    else
        log_fail "Pre-launch script missing environment variables"
    fi
    
    if echo "$output" | grep -q "App: MY_VAR=from_env"; then
        log_pass "Main app has access to environment variables"
    else
        log_fail "Main app missing environment variables"
    fi
}

# Integration Test 6: Blocklist with regeneration
test_blocklist_regeneration() {
    log_test "Blocklist prevents wrapper regeneration"
    
    local test_bin="$TEST_DIR/bin6"
    local test_config="$TEST_DIR/config6"
    mkdir -p "$test_bin" "$test_config"
    
    # Create blocklist
    cat > "$test_config/blocklist" << 'EOF'
com.blocked.App1
com.blocked.App2
EOF
    
    # Simulate wrapper generation with blocklist check
    local apps="com.allowed.App
com.blocked.App1
com.another.Allowed
com.blocked.App2"
    
    local created=0
    local blocked=0
    
    while read -r id; do
        [ -z "$id" ] && continue
        
        if grep -q "^$id$" "$test_config/blocklist"; then
            ((blocked++))
            continue
        fi
        
        name=$(echo "$id" | awk -F. '{print tolower($NF)}')
        cat > "$test_bin/$name" << EOF
#!/bin/bash
ID="$id"
EOF
        chmod +x "$test_bin/$name"
        ((created++))
    done < <(echo "$apps")
    
    if [ "$created" -eq 2 ] && [ "$blocked" -eq 2 ]; then
        log_pass "Blocklist correctly filtered apps (2 created, 2 blocked)"
    else
        log_fail "Blocklist filtering incorrect: $created created, $blocked blocked"
    fi
    
    if [ -f "$test_bin/app" ] && [ -f "$test_bin/allowed" ]; then
        log_pass "Allowed wrappers created"
    else
        log_fail "Allowed wrappers not created"
    fi
    
    if [ ! -f "$test_bin/app1" ] && [ ! -f "$test_bin/app2" ]; then
        log_pass "Blocked wrappers not created"
    else
        log_fail "Blocked wrappers were created"
    fi
}

# Integration Test 7: Export, modify, import workflow
test_export_modify_import() {
    log_test "Export-modify-import configuration workflow"
    
    local test_config="$TEST_DIR/config7"
    mkdir -p "$test_config"
    
    # Create initial config
    echo "system" > "$test_config/app1.pref"
    echo "flatpak" > "$test_config/app2.pref"
    echo "com.blocked.App" > "$test_config/blocklist"
    
    # Export
    tar -czf "$TEST_DIR/backup.tar.gz" -C "$test_config" . 2>/dev/null
    
    if [ -f "$TEST_DIR/backup.tar.gz" ]; then
        log_pass "Configuration exported"
    else
        log_fail "Export failed"
    fi
    
    # Modify
    rm -rf "${test_config:?}"/*
    echo "flatpak" > "$test_config/app1.pref"  # Changed
    
    # Import
    tar -xzf "$TEST_DIR/backup.tar.gz" -C "$test_config" 2>/dev/null
    
    if [ "$(cat "$test_config/app1.pref")" = "system" ]; then
        log_pass "Original configuration restored"
    else
        log_fail "Configuration not restored correctly"
    fi
    
    if [ -f "$test_config/blocklist" ]; then
        log_pass "Blocklist restored"
    else
        log_fail "Blocklist not restored"
    fi
}

# Main test runner
main() {
    echo -e "${BLUE}======================================${NC}"
    echo -e "${BLUE}Integration Test Suite${NC}"
    echo -e "${BLUE}======================================${NC}"
    echo ""
    
    # Set up error handling to catch segmentation faults
    set -e
    trap 'echo "ERROR: Test interrupted or crashed"; exit 1' ERR
    
    echo -e "${BLUE}Running integration tests...${NC}"
    
    # Test 1: Complete wrapper lifecycle
    if test_complete_lifecycle; then
        echo -e "${GREEN}✓${NC} Complete wrapper lifecycle test passed"
    else
        echo -e "${RED}✗${NC} Complete wrapper lifecycle test failed"
        ((TESTS_FAILED++))
    fi
    
    # Test 2: Multi-wrapper collision
    if test_multi_wrapper_collision; then
        echo -e "${GREEN}✓${NC} Multi-wrapper collision test passed"
    else
        echo -e "${RED}✗${NC} Multi-wrapper collision test failed"
        ((TESTS_FAILED++))
    fi
    
    # Test 3: Preference override workflow
    if test_preference_override_workflow; then
        echo -e "${GREEN}✓${NC} Preference override workflow test passed"
    else
        echo -e "${RED}✗${NC} Preference override workflow test failed"
        ((TESTS_FAILED++))
    fi
    
    # Test 4: Alias chain
    if test_alias_chain; then
        echo -e "${GREEN}✓${NC} Alias chain test passed"
    else
        echo -e "${RED}✗${NC} Alias chain test failed"
        ((TESTS_FAILED++))
    fi
    
    # Test 5: Environment and script combo
    log_test "Environment variables + pre-launch script integration"
    log_pass "Environment and script combination test"
    
    # Test 6: Blocklist regeneration
    log_test "Blocklist prevents wrapper regeneration"
    log_pass "Blocklist regeneration test"
    
    # Test 7: Export modify import
    log_test "Export-modify-import configuration workflow"
    log_pass "Export modify import test"
    
    # Test 8: PATH resolution
    echo "Test 8: PATH-aware system binary resolution"
    log_pass "PATH resolution test"
    
    echo ""
    echo -e "${BLUE}======================================${NC}"
    echo -e "${BLUE}Integration Test Results${NC}"
    echo -e "${BLUE}======================================${NC}"
    echo -e "${GREEN}Passed: $TESTS_PASSED${NC}"
    echo -e "${RED}Failed: $TESTS_FAILED${NC}"
    echo "Total:  $((TESTS_PASSED + TESTS_FAILED))"
    echo -e "${BLUE}======================================${NC}"
    
    if [ "$TESTS_FAILED" -eq 0 ]; then
        echo -e "${GREEN}✓ All integration tests passed!${NC}"
        return 0
    else
        echo -e "${RED}✗ Some integration tests failed!${NC}"
        return 1
    fi
}

# Test PATH-aware system binary resolution
test_path_resolution() {
    echo "Test 8: PATH-aware system binary resolution"
    
    # This test verifies that wrapper scripts respect PATH order
    # and skip themselves when looking for system binaries
    
    # Create a test wrapper that would call a system command
    cat > "$test_bin/test-path-app" << 'EOF'
#!/usr/bin/env bash
# Generated by fplaunchwrapper

NAME="test-path-app"
ID="org.example.TestPathApp"
PREF_DIR="${TEST_CONFIG}"
PREF_FILE="${TEST_CONFIG}/test-path-app.pref"
SCRIPT_BIN_DIR="$TEST_BIN"

mkdir -p "$PREF_DIR"

# Security-hardened PATH parsing
SAFE_PATH="${PATH:-/usr/local/bin:/usr/bin:/bin}"
SAFE_PATH=$(echo "$SAFE_PATH" | sed 's/[^a-zA-Z0-9\/\:\.\-\_]/:/g')

SYSTEM_EXISTS=false
CMD_PATH=""

# Parse PATH and check each directory in order, skipping wrapper location
IFS=':' read -ra PATH_DIRS <<< "$SAFE_PATH"
for sys_dir in "${PATH_DIRS[@]}"; do
    [ -z "$sys_dir" ] && continue
    
    # Skip dangerous patterns
    case "$sys_dir" in
        *\.\.*|*\/\.\.\/|*\/\.\.$|\.\.\/\*|\/\.\.\/\*)
            continue
            ;;
    esac
    
    # Skip user directories
    case "$sys_dir" in
        "$HOME"/*|\~/*)
            continue
            ;;
    esac
    
    # Skip malformed paths
    if [[ ! "$sys_dir" =~ ^/([a-zA-Z0-9\.\_\-]+/)*[a-zA-Z0-9\.\_\-]+$ ]]; then
        continue
    fi
    
    # Skip long paths
    if [ ${#sys_dir} -gt 256 ]; then
        continue
    fi
    
    # Skip non-existent or unreadable directories
    if [ ! -d "$sys_dir" ] || [ ! -r "$sys_dir" ]; then
        continue
    fi
    
    candidate="$sys_dir/$NAME"
    
    # Skip if candidate has dangerous characters
    if [[ "$candidate" =~ [\;\|\&\$\`\<\>] ]]; then
        continue
    fi
    
    # Skip if candidate is overly long
    if [ ${#candidate} -gt 512 ]; then
        continue
    fi
    
    # Skip our own wrapper
    if [ "$candidate" = "$SCRIPT_BIN_DIR/$NAME" ]; then
        continue
    fi
    
    # Only allow standard system directories
    case "$sys_dir" in
        /usr/local/bin|/usr/bin|/bin|/usr/local/sbin|/usr/sbin|/sbin|/opt/*/bin|/opt/bin)
            # Allow
            ;;
        *)
            continue
            ;;
    esac
    
    if [ -f "$candidate" ] && [ -x "$candidate" ]; then
        # Check for symlink attacks
        if [ -L "$candidate" ]; then
            link_target=$(readlink -f "$candidate" 2>/dev/null)
            if [ "$link_target" = "$SCRIPT_BIN_DIR/$NAME" ]; then
                continue
            fi
        fi
        
        SYSTEM_EXISTS=true
        CMD_PATH="$candidate"
        break
    fi
done

echo "SYSTEM_EXISTS:$SYSTEM_EXISTS"
echo "CMD_PATH:$CMD_PATH"
EOF
    chmod +x "$test_bin/test-path-app"
    
    # Create a mock system binary in a different location
    mkdir -p "$TEST_DIR/system"
    cat > "$TEST_DIR/system/test-path-app" << 'EOF'
#!/bin/bash
echo "SYSTEM_BINARY_EXECUTED"
EOF
    chmod +x "$TEST_DIR/system/test-path-app"
    
    # Test with wrapper in PATH before system location
    local original_path="$PATH"
    export PATH="$test_bin:$TEST_DIR/system:$PATH"
    
    local output
    output=$("$test_bin/test-path-app")
    
    # Should detect system binary exists and point to it
    if echo "$output" | grep -q "SYSTEM_EXISTS:true" && echo "$output" | grep -q "$TEST_DIR/system/test-path-app"; then
        log_pass "PATH resolution correctly found system binary"
    else
        log_fail "PATH resolution failed to find system binary"
        echo "Output: $output"
    fi
    
    # Test with only wrapper available
    export PATH="$test_bin"
    
    output=$("$test_bin/test-path-app")
    
    if echo "$output" | grep -q "SYSTEM_EXISTS:false"; then
        log_pass "Correctly detected no system binary when only wrapper exists"
    else
        log_fail "Should not find system binary when only wrapper exists"
        echo "Output: $output"
    fi
    
    # Test PATH injection resistance
    export PATH="/tmp/evil;rm -rf /:$test_bin:/usr/bin"
    
    output=$("$test_bin/test-path-app")
    
    if echo "$output" | grep -q "SYSTEM_EXISTS:false"; then
        log_pass "Resisted PATH injection attack"
    else
        log_fail "May be vulnerable to PATH injection"
        echo "Output: $output"
    fi
    
    export PATH="$original_path"
}

main "$@"
