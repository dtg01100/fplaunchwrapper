#!/usr/bin/env bash

# Common utility functions for fplaunchwrapper scripts

# Initialize standard paths and variables
init_paths() {
    CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/flatpak-wrappers"
    BIN_DIR_FILE="$CONFIG_DIR/bin_dir"
    BIN_DIR="${BIN_DIR:-$HOME/.local/bin}"
    
    # Load saved BIN_DIR if available
    if [ -f "$BIN_DIR_FILE" ]; then
        BIN_DIR=$(cat "$BIN_DIR_FILE")
    fi
}

# Validate that a directory is within the user's home and safe
validate_home_dir() {
    local dir="$1"
    local operation="${2:-operation}"
    
    # Check for null bytes (simple check)
    if [[ "$dir" == *\\x00* ]] || [[ "$dir" == *\\u0000* ]]; then
        echo "Error: ${operation^} contains suspicious null bytes" >&2
        return 1
    fi
    
    # Check for passwd file content (simple check)
    if [[ "$dir" == *:x:[0-9]* ]]; then
        echo "Error: ${operation^} contains suspicious content" >&2
        return 1
    fi
    
    # Check for path traversal attempts
    case "$dir" in
        *\/\.\.\/|*\/\.\.$|\.\.\/\*|\/\.\.\/\*)
            echo "Error: ${operation^} contains directory traversal attempt" >&2
            return 1
            ;;
        *\.\.*)
            # Additional check for double dots anywhere (not just as path traversal)
            if [[ "$dir" =~ \.\. ]]; then
                echo "Error: ${operation^} contains suspicious '..' pattern" >&2
                return 1
            fi
            ;;
    esac
    
    # Check for excessively long paths
    if [ ${#dir} -gt 256 ]; then
        echo "Error: ${operation^} path too long (potential buffer overflow)" >&2
        return 1
    fi
    
    # Check for dangerous characters (command injection)
    if [[ "$dir" =~ [\;\|\&\$\`\<\>] ]]; then
        echo "Error: ${operation^} contains dangerous characters" >&2
        return 1
    fi
    
    # Check that directory is within user's home
    case "$dir" in
        "$HOME"/*|"$HOME")
            return 0
            ;;
        *)
            echo "Error: ${operation^} directory must be within your home directory ($HOME)" >&2
            echo "Path: $dir" >&2
            return 1
            ;;
    esac
}

# Check if a file is a wrapper generated by fplaunchwrapper
# Uses Python for more reliable and secure validation
is_wrapper_file() {
    local file="$1"
    
    # Use Python for wrapper file validation
    python3 -c "
import sys
import os
import re

file_path = sys.argv[1]

try:
    # Must be a regular file that exists (reject symlinks for security)
    if not os.path.isfile(file_path) or os.path.islink(file_path):
        print('FAIL: Not a regular file or is a symlink')
        sys.exit(1)
    
    # Check file size - wrappers should have minimum content
    size = os.path.getsize(file_path)
    if size < 30:
        print('FAIL: File too small:', size, 'bytes')
        sys.exit(1)
    
    # Read file content
    with open(file_path, 'rb') as f:
        content_bytes = f.read()
    
    # Check for null bytes in content
    if b'\x00' in content_bytes:
        print('FAIL: Null bytes found in content')
        sys.exit(1)
    
    # Convert to text for pattern matching
    try:
        content = content_bytes.decode('utf-8')
    except UnicodeDecodeError:
        print('FAIL: File is not valid UTF-8')
        sys.exit(1)
    
    lines = content.splitlines()
    
    # Check for wrapper generation comment in first 5 lines
    found_generation_comment = False
    for i, line in enumerate(lines[:5]):
        if re.match(r'^# Generated by fplaunchwrapper$', line):
            found_generation_comment = True
            break
    
    if not found_generation_comment:
        print('FAIL: Missing wrapper generation comment')
        sys.exit(1)
    
    # Check for NAME and ID variables
    has_name = any(re.match(r'^NAME=', line) for line in lines)
    has_id = any(re.match(r'^ID=', line) for line in lines)
    
    if not has_name:
        print('FAIL: Missing NAME variable')
        sys.exit(1)
    
    if not has_id:
        print('FAIL: Missing ID variable')
        sys.exit(1)
    
    print('PASS: Valid wrapper file')
    sys.exit(0)
    
except Exception as e:
    print('FAIL: Exception:', str(e))
    sys.exit(1)
" "$file" >/dev/null 2>&1
}

# Extract Flatpak ID from a wrapper script
get_wrapper_id() {
    local script="$1"
    local id
    
    # Wrappers contain: ID="com.example.App"
    id=$(grep "^ID=" "$script" | head -1 | cut -d'"' -f2 2>/dev/null || true)
    echo "$id"
}

# Extract wrapper name from script path
get_wrapper_name() {
    local script="$1"
    
    # Wrappers contain: NAME="appname"
    basename "$script"
}

# Ensure config directory exists
ensure_config_dir() {
    CONFIG_DIR="${CONFIG_DIR:-${XDG_CONFIG_HOME:-$HOME/.config}/flatpak-wrappers}"
    mkdir -p "$CONFIG_DIR"
}

# Get the systemd user unit directory
get_systemd_unit_dir() {
    echo "${XDG_CONFIG_HOME:-$HOME/.config}/systemd/user"
}

# Stop and disable systemd units
cleanup_systemd_units() {
    local unit_prefix="${1:-flatpak-wrappers}"
    
    systemctl --user stop "${unit_prefix}.service" 2>/dev/null || true
    systemctl --user stop "${unit_prefix}.path" 2>/dev/null || true
    systemctl --user stop "${unit_prefix}.timer" 2>/dev/null || true
    systemctl --user disable "${unit_prefix}.service" 2>/dev/null || true
    systemctl --user disable "${unit_prefix}.path" 2>/dev/null || true
    systemctl --user disable "${unit_prefix}.timer" 2>/dev/null || true
    
    local unit_dir
    unit_dir=$(get_systemd_unit_dir)
    rm -f "$unit_dir/${unit_prefix}.service"
    rm -f "$unit_dir/${unit_prefix}.path"
    rm -f "$unit_dir/${unit_prefix}.timer"
    
    systemctl --user daemon-reload 2>/dev/null || true
}
