#!/usr/bin/env bash

# Common utility functions for fplaunchwrapper scripts

# Initialize standard paths and variables
init_paths() {
    CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/flatpak-wrappers"
    BIN_DIR_FILE="$CONFIG_DIR/bin_dir"
    BIN_DIR="${BIN_DIR:-$HOME/.local/bin}"
    
    # Load saved BIN_DIR if available
    if [ -f "$BIN_DIR_FILE" ]; then
        BIN_DIR=$(cat "$BIN_DIR_FILE")
    fi
}

# Validate that a directory is within the user's home and safe
validate_home_dir() {
    local dir="$1"
    local operation="${2:-operation}"
    
    # Check for null bytes (simple check)
    if [[ "$dir" == *\\x00* ]] || [[ "$dir" == *\\u0000* ]]; then
        echo "Error: ${operation^} contains suspicious null bytes" >&2
        return 1
    fi
    
    # Check for passwd file content (simple check)
    if [[ "$dir" == *:x:[0-9]* ]]; then
        echo "Error: ${operation^} contains suspicious content" >&2
        return 1
    fi
    
    # Check for path traversal attempts
    # shellcheck disable=SC2221,SC2222
    case "$dir" in
        *\.\.*|*\/\.\.\/|*\/\.\.$|\.\.\/\*|\/\.\.\/\*)
            echo "Error: ${operation^} contains directory traversal attempt" >&2
            return 1
            ;;
    esac
    
    # Check for excessively long paths
    if [ ${#dir} -gt 256 ]; then
        echo "Error: ${operation^} path too long (potential buffer overflow)" >&2
        return 1
    fi
    
    # Check for dangerous characters (command injection)
    if [[ "$dir" =~ [\;\|\&\$\`\<\>] ]]; then
        echo "Error: ${operation^} contains dangerous characters" >&2
        return 1
    fi
    
    # Check that directory is within user's home
    case "$dir" in
        "$HOME"/*|"$HOME")
            return 0
            ;;
        *)
            echo "Error: ${operation^} directory must be within your home directory ($HOME)" >&2
            echo "Path: $dir" >&2
            return 1
            ;;
    esac
}

# Check if a file is a wrapper generated by fplaunchwrapper
is_wrapper_file() {
    local file="$1"
    
    # Must be a regular file (not symlink)
    [ -f "$file" ] && [ ! -L "$file" ] || return 1
    
    # Check minimum size
    [ -s "$file" ] || return 1
    
    # Check for null bytes
    if grep -q $'\0' "$file" 2>/dev/null; then
        return 1
    fi
    
    # Check for wrapper generation comment in first 5 lines
    if ! head -5 "$file" | grep -q "^# Generated by fplaunchwrapper$"; then
        return 1
    fi
    
    # Check for required variables
    grep -q "^NAME=" "$file" && grep -q "^ID=" "$file"
}

# Extract Flatpak ID from a wrapper script
get_wrapper_id() {
    local script="$1"
    local id
    
    # Wrappers contain: ID="com.example.App"
    id=$(grep "^ID=" "$script" | head -1 | cut -d'"' -f2 2>/dev/null || true)
    echo "$id"
}

# Extract wrapper name from script path
get_wrapper_name() {
    local script="$1"
    
    # Wrappers contain: NAME="appname"
    basename "$script"
}

# Ensure config directory exists
ensure_config_dir() {
    CONFIG_DIR="${CONFIG_DIR:-${XDG_CONFIG_HOME:-$HOME/.config}/flatpak-wrappers}"
    mkdir -p "$CONFIG_DIR"
}

# Get the systemd user unit directory
get_systemd_unit_dir() {
    echo "${XDG_CONFIG_HOME:-$HOME/.config}/systemd/user"
}

# Stop and disable systemd units
cleanup_systemd_units() {
    local unit_prefix="${1:-flatpak-wrappers}"
    
    systemctl --user stop "${unit_prefix}.service" 2>/dev/null || true
    systemctl --user stop "${unit_prefix}.path" 2>/dev/null || true
    systemctl --user stop "${unit_prefix}.timer" 2>/dev/null || true
    systemctl --user disable "${unit_prefix}.service" 2>/dev/null || true
    systemctl --user disable "${unit_prefix}.path" 2>/dev/null || true
    systemctl --user disable "${unit_prefix}.timer" 2>/dev/null || true
    
    local unit_dir
    unit_dir=$(get_systemd_unit_dir)
    rm -f "$unit_dir/${unit_prefix}.service"
    rm -f "$unit_dir/${unit_prefix}.path"
    rm -f "$unit_dir/${unit_prefix}.timer"
    
    systemctl --user daemon-reload 2>/dev/null || true
}

# Consolidated config management functions
export_prefs() {
    local file="$1"
    local pref_files
    pref_files=$(find "$CONFIG_DIR" -maxdepth 1 -name "*.pref" -type f -exec basename {} \; 2>/dev/null)
    if [ -n "$pref_files" ]; then
        tar -czf "$file" -C "$CONFIG_DIR" blocklist $pref_files 2>/dev/null
    else
        tar -czf "$file" -C "$CONFIG_DIR" blocklist 2>/dev/null
    fi
    echo "Exported preferences to $file"
}

import_prefs() {
    local file="$1"
    if [ -f "$file" ]; then
        if tar -tzf "$file" 2>/dev/null | grep -q '\.\.'; then
            echo "Error: Archive contains suspicious paths. Import cancelled for security."
            return 1
        fi
        tar -xzf "$file" -C "$CONFIG_DIR" 2>/dev/null
        echo "Imported preferences from $file"
    else
        echo "File $file not found"
    fi
}

export_config() {
    local file="$1"
    tar -czf "$file" -C "$CONFIG_DIR" . 2>/dev/null
    echo "Exported full config to $file"
}

import_config() {
    local file="$1"
    if [ -f "$file" ]; then
        if tar -tzf "$file" 2>/dev/null | grep -q '\.\.'; then
            echo "Error: Archive contains suspicious paths. Import cancelled for security."
            return 1
        fi
        tar -xzf "$file" -C "$CONFIG_DIR" 2>/dev/null
        echo "Imported full config from $file"
    else
        echo "File $file not found"
    fi
}

# Cron management helper
manage_cron_entry() {
    local action="$1"
    local script_path="$2"
    
    case "$action" in
        remove)
            if command -v crontab &> /dev/null; then
                crontab -l 2>/dev/null | grep -v "$script_path" | crontab - 2>/dev/null || true
            fi
            ;;
    esac
}

# Confirmation helper
confirm_action() {
    local message="$1"
    local default="${2:-n}"
    read -r -p "$message (y/n) [$default]: " confirm
    confirm="${confirm:-$default}"
    [[ $confirm =~ ^[Yy]$ ]]
}

# Wrapper validation helper  
validate_wrapper_exists() {
    local name="$1"
    if [ ! -f "$BIN_DIR/$name" ]; then
        echo "Wrapper $name not found" >&2
        return 1
    fi
}

# Safe directory creation helper
ensure_directory() {
    local dir="$1"
    [ -d "$dir" ] || mkdir -p "$dir"
}

# Make executable helper
make_executable() {
    local file="$1"
    [ -x "$file" ] || chmod +x "$file"
}
