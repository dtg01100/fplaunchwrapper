#!/usr/bin/env python3
"""
Wrapper management functionality for fplaunchwrapper
Replaces fplaunch-manage bash script with Python implementation
"""

import os
import sys
import shutil
from pathlib import Path
from typing import List, Optional, Dict

try:
    from rich.console import Console
    from rich.table import Table

    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False

# Import our utilities
try:
    from python_utils import (
        find_executable,
        sanitize_id_to_name,
        is_wrapper_file,
        get_wrapper_id,
        validate_home_dir,
    )

    UTILS_AVAILABLE = True
except ImportError:
    UTILS_AVAILABLE = False

console = Console() if RICH_AVAILABLE else None


class WrapperManager:
    """Manages Flatpak application wrappers"""

    def __init__(self, config_dir: Optional[str] = None, verbose: bool = False):
        self.verbose = verbose
        self.config_dir = Path(
            config_dir or (Path.home() / ".config" / "fplaunchwrapper")
        )

        # Get bin directory from config
        bin_dir_file = self.config_dir / "bin_dir"
        if bin_dir_file.exists():
            self.bin_dir = Path(bin_dir_file.read_text().strip())
        else:
            self.bin_dir = Path.home() / "bin"

        # Ensure directories exist
        self.bin_dir.mkdir(parents=True, exist_ok=True)
        self.config_dir.mkdir(parents=True, exist_ok=True)

    def log(self, message: str, level: str = "info"):
        """Log a message"""
        if self.verbose or level in ["error", "warning"]:
            if console:
                if level == "error":
                    console.print(f"[red]ERROR:[/red] {message}")
                elif level == "warning":
                    console.print(f"[yellow]WARN:[/yellow] {message}")
                elif level == "success":
                    console.print(f"[green]âœ“[/green] {message}")
                else:
                    console.print(message)
            else:
                print(f"[{level.upper()}] {message}")

    def list_wrappers(self) -> List[Dict[str, str]]:
        """List all installed wrappers"""
        wrappers = []

        if not self.bin_dir.exists():
            return wrappers

        for item in self.bin_dir.iterdir():
            if item.is_file() and os.access(item, os.X_OK):
                if UTILS_AVAILABLE and is_wrapper_file(str(item)):
                    wrapper_id = get_wrapper_id(str(item))
                    wrappers.append(
                        {
                            "name": item.name,
                            "path": str(item),
                            "id": wrapper_id or "unknown",
                        }
                    )
                else:
                    # Fallback: check if it looks like a wrapper
                    try:
                        content = item.read_text()
                        if "Generated by fplaunchwrapper" in content:
                            # Try to extract ID from content
                            wrapper_id = "unknown"
                            for line in content.split("\n"):
                                if line.startswith('ID="') and line.endswith('"'):
                                    wrapper_id = line[4:-1]
                                    break
                            wrappers.append(
                                {"name": item.name, "path": str(item), "id": wrapper_id}
                            )
                    except:
                        pass

        return wrappers

    def display_wrappers(self):
        """Display wrappers in a nice format"""
        wrappers = self.list_wrappers()

        if not wrappers:
            if console:
                console.print("[yellow]No wrappers found[/yellow]")
                console.print(
                    f"Run 'fplaunch generate {self.bin_dir}' to create wrappers"
                )
            else:
                print("No wrappers found")
                print(f"Run 'fplaunch generate {self.bin_dir}' to create wrappers")
            return

        if console:
            table = Table(title="Flatpak Wrappers")
            table.add_column("Wrapper", style="cyan", no_wrap=True)
            table.add_column("Flatpak ID", style="magenta")
            table.add_column("Path", style="dim")

            for wrapper in wrappers:
                table.add_row(wrapper["name"], wrapper["id"], wrapper["path"])

            console.print(table)
            console.print(f"\n[green]{len(wrappers)}[/green] wrappers found")
        else:
            print("Current wrappers:")
            for wrapper in wrappers:
                print(f"  {wrapper['name']} -> {wrapper['id']}")

    def remove_wrapper(self, wrapper_name: str, force: bool = False) -> bool:
        """Remove a specific wrapper"""
        wrapper_path = self.bin_dir / wrapper_name

        if not wrapper_path.exists():
            self.log(f"Wrapper '{wrapper_name}' not found", "error")
            return False

        # Confirm removal unless forced
        if not force:
            if console:
                from rich.prompt import Confirm

                if not Confirm.ask(
                    f"Are you sure you want to remove wrapper '{wrapper_name}'?"
                ):
                    console.print("[yellow]Removal cancelled[/yellow]")
                    return False
            else:
                response = input(
                    f"Are you sure you want to remove wrapper '{wrapper_name}'? (y/n): "
                )
                if response.lower() not in ["y", "yes"]:
                    print("Removal cancelled.")
                    return False

        try:
            # Remove wrapper file
            wrapper_path.unlink()
            self.log(f"Removed wrapper: {wrapper_name}", "success")

            # Remove preference file
            pref_file = self.config_dir / f"{wrapper_name}.pref"
            if pref_file.exists():
                pref_file.unlink()
                self.log(f"Removed preference file for: {wrapper_name}")

            # Remove aliases
            aliases_file = self.config_dir / "aliases"
            if aliases_file.exists():
                try:
                    content = aliases_file.read_text()
                    lines = content.split("\n")
                    new_lines = []

                    for line in lines:
                        if line.strip() and not line.startswith(f"{wrapper_name} "):
                            new_lines.append(line)

                    if new_lines:
                        aliases_file.write_text("\n".join(new_lines))
                    else:
                        aliases_file.unlink()

                    self.log(f"Removed aliases for: {wrapper_name}")

                except Exception as e:
                    self.log(f"Warning: Could not remove aliases: {e}", "warning")

            # Remove symlinks pointing to this wrapper
            if self.bin_dir.exists():
                for item in self.bin_dir.iterdir():
                    if item.is_symlink() and item.readlink() == wrapper_path:
                        try:
                            item.unlink()
                            self.log(f"Removed symlink: {item.name}")
                        except Exception as e:
                            self.log(
                                f"Warning: Could not remove symlink {item.name}: {e}",
                                "warning",
                            )

            return True

        except Exception as e:
            self.log(f"Failed to remove wrapper '{wrapper_name}': {e}", "error")
            return False

    def set_preference(self, wrapper_name: str, preference: str) -> bool:
        """Set launch preference for a wrapper"""
        if preference not in ["system", "flatpak"]:
            self.log(
                f"Invalid preference: {preference}. Use 'system' or 'flatpak'", "error"
            )
            return False

        pref_file = self.config_dir / f"{wrapper_name}.pref"

        try:
            pref_file.write_text(preference)
            self.log(
                f"Set preference for '{wrapper_name}' to '{preference}'", "success"
            )
            return True
        except Exception as e:
            self.log(f"Failed to set preference for '{wrapper_name}': {e}", "error")
            return False

    def get_preference(self, wrapper_name: str) -> Optional[str]:
        """Get launch preference for a wrapper"""
        pref_file = self.config_dir / f"{wrapper_name}.pref"

        if pref_file.exists():
            try:
                return pref_file.read_text().strip()
            except Exception:
                pass

        return None

    def set_preference_all(self, preference: str) -> int:
        """Set preference for all wrappers"""
        if preference not in ["system", "flatpak"]:
            self.log(
                f"Invalid preference: {preference}. Use 'system' or 'flatpak'", "error"
            )
            return 0

        wrappers = self.list_wrappers()
        updated_count = 0

        for wrapper in wrappers:
            if self.set_preference(wrapper["name"], preference):
                updated_count += 1

        if updated_count > 0:
            self.log(
                f"Set preference to '{preference}' for {updated_count} wrappers",
                "success",
            )

        return updated_count

    def show_info(self, wrapper_name: str):
        """Show detailed information about a wrapper"""
        wrapper_path = self.bin_dir / wrapper_name

        if not wrapper_path.exists():
            self.log(f"Wrapper '{wrapper_name}' not found", "error")
            return False

        # Get wrapper information
        wrapper_id = None
        preference = self.get_preference(wrapper_name)

        if UTILS_AVAILABLE and is_wrapper_file(str(wrapper_path)):
            wrapper_id = get_wrapper_id(str(wrapper_path))

        if console:
            from rich.panel import Panel

            info_lines = [
                f"[bold]Wrapper:[/bold] {wrapper_name}",
                f"[bold]Path:[/bold] {wrapper_path}",
                f"[bold]Flatpak ID:[/bold] {wrapper_id or 'Unknown'}",
                f"[bold]Preference:[/bold] {preference or 'Not set'}",
                f"[bold]Executable:[/bold] {'Yes' if os.access(wrapper_path, os.X_OK) else 'No'}",
            ]

            # Check if Flatpak app exists
            if wrapper_id and find_executable("flatpak"):
                import subprocess

                result = subprocess.run(
                    ["flatpak", "info", wrapper_id], capture_output=True, text=True
                )
                if result.returncode == 0:
                    info_lines.append(f"[bold]Flatpak Status:[/bold] Installed")
                else:
                    info_lines.append(f"[bold]Flatpak Status:[/bold] Not installed")

            console.print(
                Panel.fit(
                    "\n".join(info_lines), title=f"Wrapper Information: {wrapper_name}"
                )
            )
        else:
            print(f"Wrapper: {wrapper_name}")
            print(f"Path: {wrapper_path}")
            print(f"Flatpak ID: {wrapper_id or 'Unknown'}")
            print(f"Preference: {preference or 'Not set'}")
            print(f"Executable: {'Yes' if os.access(wrapper_path, os.X_OK) else 'No'}")

        return True

    def discover_features(self):
        """Discover and show available features"""
        features = [
            (
                "Wrapper Generation",
                "Automatically create launch scripts for Flatpak apps",
            ),
            ("Launch Preferences", "Choose between system packages and Flatpak apps"),
            ("Automatic Updates", "Monitor for app changes and update wrappers"),
            ("Interactive Mode", "Choose launch method interactively"),
            ("Script Integration", "Pre/post-launch scripts for customization"),
            ("Alias Support", "Create custom aliases for wrappers"),
            ("Configuration", "TOML-based configuration with validation"),
        ]

        if console:
            table = Table(title="fplaunchwrapper Features")
            table.add_column("Feature", style="cyan", no_wrap=True)
            table.add_column("Description", style="white")

            for feature, description in features:
                table.add_row(feature, description)

            console.print(table)

            # Show usage examples
            console.print("\n[bold]Usage Examples:[/bold]")
            examples = [
                "fplaunch generate ~/bin          # Generate wrappers",
                "fplaunch list                     # List all wrappers",
                "fplaunch set-pref firefox flatpak # Set preference",
                "fplaunch monitor                  # Monitor for changes",
                "firefox --fpwrapper-help          # Wrapper help",
            ]

            for example in examples:
                console.print(f"  [green]$[/green] {example}")

        else:
            print("fplaunchwrapper Features:")
            for feature, description in features:
                print(f"  {feature}: {description}")

    def cleanup_obsolete(self) -> int:
        """Clean up wrappers for uninstalled applications"""
        self.log("Cleaning up obsolete wrappers...")

        # This would need to check installed Flatpak apps
        # For now, just return 0
        self.log("Cleanup not yet implemented in Python version", "warning")
        return 0


def main():
    """Command-line interface for wrapper management"""
    import argparse

    parser = argparse.ArgumentParser(
        description="Manage Flatpak application wrappers",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "command",
        choices=["list", "remove", "set-pref", "info", "discover", "cleanup"],
        help="Command to execute",
    )

    parser.add_argument("args", nargs="*", help="Command arguments")

    parser.add_argument("--config-dir", "-c", help="Configuration directory")

    parser.add_argument(
        "--verbose", "-v", action="store_true", help="Enable verbose output"
    )

    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force operations without confirmation",
    )

    args = parser.parse_args()

    manager = WrapperManager(args.config_dir, args.verbose)

    try:
        if args.command == "list":
            manager.display_wrappers()

        elif args.command == "remove":
            if not args.args:
                parser.error("remove requires a wrapper name")
            success = manager.remove_wrapper(args.args[0], args.force)
            return 0 if success else 1

        elif args.command == "set-pref":
            if len(args.args) != 2:
                parser.error(
                    "set-pref requires wrapper name and preference (system|flatpak)"
                )
            success = manager.set_preference(args.args[0], args.args[1])
            return 0 if success else 1

        elif args.command == "info":
            if not args.args:
                parser.error("info requires a wrapper name")
            success = manager.show_info(args.args[0])
            return 0 if success else 1

        elif args.command == "discover":
            manager.discover_features()

        elif args.command == "cleanup":
            removed_count = manager.cleanup_obsolete()
            manager.log(f"Cleaned up {removed_count} obsolete wrappers")

        return 0

    except Exception as e:
        if console:
            console.print(f"[red]Error:[/red] {e}")
        else:
            print(f"Error: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
