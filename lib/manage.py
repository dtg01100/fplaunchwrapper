#!/usr/bin/env python3
"""Wrapper management functionality for fplaunchwrapper
Replaces fplaunch-manage bash script with Python implementation.
"""

from __future__ import annotations

import os
import sys
from pathlib import Path

try:
    from rich.console import Console
    from rich.table import Table

    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False

# Import our utilities
try:
    from .python_utils import (
        find_executable,
        get_wrapper_id,
        is_wrapper_file,
        sanitize_id_to_name,
        validate_home_dir,
    )

    UTILS_AVAILABLE = True
except ImportError:
    UTILS_AVAILABLE = False

console = Console() if RICH_AVAILABLE else None


class WrapperManager:
    """Manages Flatpak application wrappers."""

    def __init__(
        self,
        config_dir: str | None = None,
        bin_dir: str | None = None,
        verbose: bool = False,
        emit_mode: bool = False,
        emit_verbose: bool = False,
    ) -> None:
        # Backwards compatibility: allow positional booleans for verbose/emit flags
        if isinstance(bin_dir, bool):
            verbose, emit_mode, emit_verbose = bin_dir, verbose, emit_mode
            bin_dir = None

        self.verbose = verbose
        self.emit_mode = emit_mode
        self.emit_verbose = emit_verbose
        self.config_dir = Path(
            config_dir or (Path.home() / ".config" / "fplaunchwrapper"),
        )

        # Get bin directory - prioritize parameter, then config, then default
        if bin_dir:
            self.bin_dir = Path(bin_dir)
        else:
            bin_dir_file = self.config_dir / "bin_dir"
            try:
                if bin_dir_file.exists():
                    bin_dir_path = bin_dir_file.read_text().strip()
                    if bin_dir_path:
                        self.bin_dir = Path(bin_dir_path)
                    else:
                        self.bin_dir = Path.home() / "bin"
                else:
                    self.bin_dir = Path.home() / "bin"
            except (OSError, UnicodeDecodeError):
                # If we can't read the config file for any reason, fall back to default
                self.bin_dir = Path.home() / "bin"

        # Ensure directories exist (unless in emit mode)
        if not emit_mode:
            self.bin_dir.mkdir(parents=True, exist_ok=True)
            self.config_dir.mkdir(parents=True, exist_ok=True)

    def log(self, message: str, level: str = "info") -> None:
        """Log a message."""
        if self.verbose or level in ["error", "warning"]:
            if console:
                if level == "error":
                    console.print(f"[red]ERROR:[/red] {message}")
                elif level == "warning":
                    console.print(f"[yellow]WARN:[/yellow] {message}")
                elif level == "success":
                    console.print(f"[green]âœ“[/green] {message}")
                else:
                    console.print(message)
            else:
                pass

    def list_wrappers(self) -> list[dict[str, str]]:
        """List all installed wrappers."""
        wrappers = []

        if not self.bin_dir.exists():
            return wrappers

        for item in self.bin_dir.iterdir():
            if item.is_file() and os.access(item, os.X_OK):
                if UTILS_AVAILABLE and is_wrapper_file(str(item)):
                    wrapper_id = get_wrapper_id(str(item))
                    wrappers.append(
                        {
                            "name": item.name,
                            "path": str(item),
                            "id": wrapper_id or "unknown",
                        },
                    )
                else:
                    # Fallback: check if it looks like a wrapper
                    try:
                        content = item.read_text()
                        if "Generated by fplaunchwrapper" in content:
                            # Try to extract ID from content
                            wrapper_id = "unknown"
                            for line in content.split("\n"):
                                if line.startswith('ID="') and line.endswith('"'):
                                    wrapper_id = line[4:-1]
                                    break
                            wrappers.append(
                                {
                                    "name": item.name,
                                    "path": str(item),
                                    "id": wrapper_id,
                                },
                            )
                    except:
                        pass

        return wrappers

    def display_wrappers(self) -> None:
        """Display wrappers in a nice format."""
        wrappers = self.list_wrappers()

        if not wrappers:
            if console:
                console.print("[yellow]No wrappers found[/yellow]")
                console.print(
                    f"Run 'fplaunch generate {self.bin_dir}' to create wrappers",
                )
            else:
                pass
            return

        if console:
            table = Table(title="Flatpak Wrappers")
            table.add_column("Wrapper", style="cyan", no_wrap=True)
            table.add_column("Flatpak ID", style="magenta")
            table.add_column("Path", style="dim")

            for wrapper in wrappers:
                table.add_row(wrapper["name"], wrapper["id"], wrapper["path"])

            console.print(table)
            console.print(f"\n[green]{len(wrappers)}[/green] wrappers found")
        else:
            for wrapper in wrappers:
                pass

    def remove_wrapper(self, wrapper_name: str, force: bool = False) -> bool:
        """Remove a specific wrapper."""
        wrapper_path = self.bin_dir / wrapper_name

        if not wrapper_path.exists() and not self.emit_mode:
            self.log(f"Wrapper '{wrapper_name}' not found", "error")
            return False

        # Confirm removal unless forced or in emit mode
        if not force and not self.emit_mode:
            if console:
                from rich.prompt import Confirm

                if not Confirm.ask(
                    f"Are you sure you want to remove wrapper '{wrapper_name}'?",
                ):
                    console.print("[yellow]Removal cancelled[/yellow]")
                    return False
            else:
                response = input(
                    f"Are you sure you want to remove wrapper '{wrapper_name}'? (y/n): ",
                )
                if response.lower() not in ["y", "yes"]:
                    return False

        # In emit mode, just show what would be done
        if self.emit_mode:
            self.log(f"EMIT: Would remove wrapper: {wrapper_name}")

            pref_file = self.config_dir / f"{wrapper_name}.pref"
            if pref_file.exists():
                self.log(f"EMIT: Would remove preference file: {pref_file}")

            aliases_file = self.config_dir / "aliases"
            if aliases_file.exists():
                self.log(f"EMIT: Would update aliases file: {aliases_file}")

            if self.bin_dir.exists():
                for item in self.bin_dir.iterdir():
                    if item.is_symlink() and item.readlink() == wrapper_path:
                        self.log(f"EMIT: Would remove symlink: {item.name}")

            return True

        try:
            # Remove wrapper file
            wrapper_path.unlink()
            self.log(f"Removed wrapper: {wrapper_name}", "success")

            # Remove preference file
            pref_file = self.config_dir / f"{wrapper_name}.pref"
            if pref_file.exists():
                pref_file.unlink()
                self.log(f"Removed preference file for: {wrapper_name}")

            # Remove environment file
            env_file = self.config_dir / f"{wrapper_name}.env"
            if env_file.exists():
                env_file.unlink()
                self.log(f"Removed environment file for: {wrapper_name}")

            # Remove aliases
            aliases_file = self.config_dir / "aliases"
            if aliases_file.exists():
                try:
                    content = aliases_file.read_text()
                    lines = content.split("\n")
                    new_lines = []

                    for line in lines:
                        if line.strip():
                            # Check if this alias points to the wrapper we're removing
                            if ":" in line:
                                _, target = line.split(":", 1)
                                if target.strip() != wrapper_name:
                                    new_lines.append(line)
                            else:
                                new_lines.append(line)

                    if new_lines:
                        aliases_file.write_text("\n".join(new_lines))
                    else:
                        aliases_file.unlink()

                    self.log(f"Removed aliases for: {wrapper_name}")

                except Exception as e:
                    self.log(f"Warning: Could not remove aliases: {e}", "warning")

            # Remove symlinks pointing to this wrapper
            if self.bin_dir.exists():
                for item in self.bin_dir.iterdir():
                    if item.is_symlink() and item.readlink() == wrapper_path:
                        try:
                            item.unlink()
                            self.log(f"Removed symlink: {item.name}")
                        except Exception as e:
                            self.log(
                                f"Warning: Could not remove symlink {item.name}: {e}",
                                "warning",
                            )

            return True

        except Exception as e:
            self.log(f"Failed to remove wrapper '{wrapper_name}': {e}", "error")
            return False

        # Confirm removal unless forced
        if not force:
            if console:
                from rich.prompt import Confirm

                if not Confirm.ask(
                    f"Are you sure you want to remove wrapper '{wrapper_name}'?",
                ):
                    console.print("[yellow]Removal cancelled[/yellow]")
                    return False
            else:
                response = input(
                    f"Are you sure you want to remove wrapper '{wrapper_name}'? (y/n): ",
                )
                if response.lower() not in ["y", "yes"]:
                    return False

        try:
            # Remove wrapper file
            wrapper_path.unlink()
            self.log(f"Removed wrapper: {wrapper_name}", "success")

            # Remove preference file
            pref_file = self.config_dir / f"{wrapper_name}.pref"
            if pref_file.exists():
                pref_file.unlink()
                self.log(f"Removed preference file for: {wrapper_name}")

            # Remove aliases
            aliases_file = self.config_dir / "aliases"
            if aliases_file.exists():
                try:
                    content = aliases_file.read_text()
                    lines = content.split("\n")
                    new_lines = []

                    for line in lines:
                        if line.strip() and not line.startswith(f"{wrapper_name} "):
                            new_lines.append(line)

                    if new_lines:
                        aliases_file.write_text("\n".join(new_lines))
                    else:
                        aliases_file.unlink()

                    self.log(f"Removed aliases for: {wrapper_name}")

                except Exception as e:
                    self.log(f"Warning: Could not remove aliases: {e}", "warning")

            # Remove symlinks pointing to this wrapper
            if self.bin_dir.exists():
                for item in self.bin_dir.iterdir():
                    if item.is_symlink() and item.readlink() == wrapper_path:
                        try:
                            item.unlink()
                            self.log(f"Removed symlink: {item.name}")
                        except Exception as e:
                            self.log(
                                f"Warning: Could not remove symlink {item.name}: {e}",
                                "warning",
                            )

            return True

        except Exception as e:
            self.log(f"Failed to remove wrapper '{wrapper_name}': {e}", "error")
            return False

    def set_preference(self, wrapper_name: str, preference: str) -> bool:
        """Set launch preference for a wrapper."""
        # Validate inputs
        if (
            not wrapper_name
            or not isinstance(wrapper_name, str)
            or not wrapper_name.strip()
        ):
            self.log("Invalid wrapper name: must be a non-empty string", "error")
            return False

        if not preference or not isinstance(preference, str) or not preference.strip():
            self.log("Invalid preference: must be a non-empty string", "error")
            return False

        # Accept traditional modes and sanitized Flatpak IDs
        if preference not in ["system", "flatpak"]:
            import re

            if not re.match(r"^[A-Za-z0-9._-]+$", preference):
                self.log(
                    f"Invalid preference: {preference}. Use 'system', 'flatpak', or a valid Flatpak ID",
                    "error",
                )
                return False

        pref_file = self.config_dir / f"{wrapper_name}.pref"

        if self.emit_mode:
            self.log(f"EMIT: Would write '{preference}' to {pref_file}")

            # Show file content if verbose emit mode
            if self.emit_verbose:
                self.log(f"EMIT: File content for {pref_file}:")
                if console:
                    from rich.panel import Panel

                    console.print(
                        Panel.fit(
                            preference,
                            title=f"ðŸ“„ {wrapper_name}.pref preference file",
                            border_style="green",
                        ),
                    )
                    # Also print raw content for tests that capture stdout
                    print(preference)
                else:
                    self.log("-" * 30)
                    self.log(f"Content: {preference}")
                    self.log("-" * 30)

            return True
        try:
            pref_file.write_text(preference)
            self.log(
                f"Set preference for '{wrapper_name}' to '{preference}'",
                "success",
            )
            return True
        except Exception as e:
            self.log(f"Failed to set preference for '{wrapper_name}': {e}", "error")
            return False

        pref_file = self.config_dir / f"{wrapper_name}.pref"

        try:
            pref_file.write_text(preference)
            self.log(
                f"Set preference for '{wrapper_name}' to '{preference}'",
                "success",
            )
            return True
        except Exception as e:
            self.log(f"Failed to set preference for '{wrapper_name}': {e}", "error")
            return False

    def get_preference(self, wrapper_name: str) -> str | None:
        """Get launch preference for a wrapper."""
        pref_file = self.config_dir / f"{wrapper_name}.pref"

        if pref_file.exists():
            try:
                return pref_file.read_text().strip()
            except Exception:
                pass

        return None

    def set_preference_all(self, preference: str) -> int:
        """Set preference for all wrappers."""
        if preference not in ["system", "flatpak"]:
            self.log(
                f"Invalid preference: {preference}. Use 'system' or 'flatpak'",
                "error",
            )
            return 0

        wrappers = self.list_wrappers()
        updated_count = 0

        for wrapper in wrappers:
            if self.set_preference(wrapper["name"], preference):
                updated_count += 1

        if updated_count > 0:
            self.log(
                f"Set preference to '{preference}' for {updated_count} wrappers",
                "success",
            )

        return updated_count

    def show_info(self, wrapper_name: str) -> bool:
        """Show detailed information about a wrapper."""
        wrapper_path = self.bin_dir / wrapper_name

        if not wrapper_path.exists():
            self.log(f"Wrapper '{wrapper_name}' not found", "error")
            return False

        # Get wrapper information
        wrapper_id = None
        preference = self.get_preference(wrapper_name)

        if UTILS_AVAILABLE and is_wrapper_file(str(wrapper_path)):
            wrapper_id = get_wrapper_id(str(wrapper_path))

        if console:
            from rich.panel import Panel

            info_lines = [
                f"[bold]Wrapper:[/bold] {wrapper_name}",
                f"[bold]Path:[/bold] {wrapper_path}",
                f"[bold]Flatpak ID:[/bold] {wrapper_id or 'Unknown'}",
                f"[bold]Preference:[/bold] {preference or 'Not set'}",
                f"[bold]Executable:[/bold] {'Yes' if os.access(wrapper_path, os.X_OK) else 'No'}",
            ]

            # Check if Flatpak app exists
            flatpak_path = find_executable("flatpak")
            if wrapper_id and flatpak_path:
                import subprocess

                result = subprocess.run(
                    [flatpak_path, "info", wrapper_id],
                    check=False,
                    capture_output=True,
                    text=True,
                )
                if result.returncode == 0:
                    info_lines.append("[bold]Flatpak Status:[/bold] Installed")
                else:
                    info_lines.append("[bold]Flatpak Status:[/bold] Not installed")

            console.print(
                Panel.fit(
                    "\n".join(info_lines),
                    title=f"Wrapper Information: {wrapper_name}",
                ),
            )
        else:
            pass

        return True

    def discover_features(self) -> None:
        """Discover and show available features."""
        features = [
            (
                "Wrapper Generation",
                "Automatically create launch scripts for Flatpak apps",
            ),
            ("Launch Preferences", "Choose between system packages and Flatpak apps"),
            ("Automatic Updates", "Monitor for app changes and update wrappers"),
            ("Interactive Mode", "Choose launch method interactively"),
            ("Script Integration", "Pre/post-launch scripts for customization"),
            ("Alias Support", "Create custom aliases for wrappers"),
            ("Configuration", "TOML-based configuration with validation"),
        ]

        if console:
            table = Table(title="fplaunchwrapper Features")
            table.add_column("Feature", style="cyan", no_wrap=True)
            table.add_column("Description", style="white")

            for feature, description in features:
                table.add_row(feature, description)

            console.print(table)

            # Show usage examples
            console.print("\n[bold]Usage Examples:[/bold]")
            examples = [
                "fplaunch generate ~/bin          # Generate wrappers",
                "fplaunch list                     # List all wrappers",
                "fplaunch set-pref firefox flatpak # Set preference",
                "fplaunch monitor                  # Monitor for changes",
                "firefox --fpwrapper-help          # Wrapper help",
            ]

            for example in examples:
                console.print(f"  [green]$[/green] {example}")

        else:
            for feature, description in features:
                pass

    def cleanup_obsolete(self) -> int:
        """Clean up wrappers for uninstalled applications."""
        self.log("Cleaning up obsolete wrappers...")

        # This would need to check installed Flatpak apps
        # For now, just return 0
        self.log("Cleanup not yet implemented in Python version", "warning")
        return 0

    def create_alias(self, alias_name: str, target_wrapper: str) -> bool:
        """Create an alias for a wrapper."""
        self.log(f"Creating alias '{alias_name}' -> '{target_wrapper}'...")

        # Store aliases in config file
        aliases_file = self.config_dir / "aliases"

        try:
            # Read existing aliases
            if aliases_file.exists():
                aliases_content = aliases_file.read_text()
                aliases = dict(
                    line.split(":", 1)
                    for line in aliases_content.strip().split("\n")
                    if ":" in line
                )
            else:
                aliases = {}

            # Check if alias already exists
            if alias_name in aliases:
                self.log(f"Alias '{alias_name}' already exists", "warning")
                return False

            # Add new alias
            aliases[alias_name] = target_wrapper

            # Write back to file
            aliases_file.write_text(
                "\n".join(f"{k}:{v}" for k, v in aliases.items()) + "\n"
            )

            self.log(f"Created alias: {alias_name}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to create alias: {e}", "error")
            return False

    def block_app(self, app_id: str) -> bool:
        """Add an application to the blocklist."""
        self.log(f"Blocking application: {app_id}...")

        blocklist_file = self.config_dir / "blocklist"

        try:
            # Read existing blocklist
            if blocklist_file.exists():
                blocklist = set(blocklist_file.read_text().strip().split("\n"))
            else:
                blocklist = set()

            # Add app to blocklist
            if app_id in blocklist:
                self.log(f"Application '{app_id}' already blocked", "warning")
                return True

            blocklist.add(app_id)
            blocklist_file.write_text("\n".join(sorted(blocklist)) + "\n")

            self.log(f"Blocked application: {app_id}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to block application: {e}", "error")
            return False

    def unblock_app(self, app_id: str) -> bool:
        """Remove an application from the blocklist."""
        self.log(f"Unblocking application: {app_id}...")

        blocklist_file = self.config_dir / "blocklist"

        try:
            if not blocklist_file.exists():
                self.log(f"Application '{app_id}' not in blocklist", "warning")
                return True  # Idempotent - return True even if not blocked

            # Read existing blocklist
            blocklist = set(blocklist_file.read_text().strip().split("\n"))

            # Remove app from blocklist
            if app_id not in blocklist:
                self.log(f"Application '{app_id}' not in blocklist", "warning")
                return True  # Idempotent - return True even if not blocked

            blocklist.remove(app_id)
            if blocklist:
                blocklist_file.write_text("\n".join(sorted(blocklist)) + "\n")
            else:
                blocklist_file.unlink()

            self.log(f"Unblocked application: {app_id}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to unblock application: {e}", "error")
            return False

    def set_environment_variable(
        self, wrapper_name: str, var_name: str, var_value: str
    ) -> bool:
        """Set an environment variable for a wrapper."""
        self.log(f"Setting {var_name}={var_value} for {wrapper_name}...")

        env_file = self.config_dir / f"{wrapper_name}.env"

        try:
            # Read existing env file if it exists
            if env_file.exists():
                content = env_file.read_text()
                lines = content.strip().split("\n")
            else:
                lines = []

            # Update or add the variable
            found = False
            for i, line in enumerate(lines):
                if line.startswith(f"{var_name}="):
                    lines[i] = f"{var_name}={var_value}"
                    found = True
                    break

            if not found:
                lines.append(f"{var_name}={var_value}")

            # Write back to file
            env_file.write_text("\n".join(lines) + "\n" if lines else "")

            self.log(f"Set environment variable: {var_name}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to set environment variable: {e}", "error")
            return False

    def export_preferences(self, export_path: str) -> bool:
        """Export preferences and aliases to a file."""
        self.log(f"Exporting preferences to {export_path}...")

        try:
            import json

            data = {"preferences": {}, "aliases": {}, "environment_variables": {}}
            pref_dir = self.config_dir

            # Collect all .pref files
            for pref_file in pref_dir.glob("*.pref"):
                wrapper_name = pref_file.stem
                preference = pref_file.read_text().strip()
                data["preferences"][wrapper_name] = preference

            # Collect aliases
            aliases_file = self.config_dir / "aliases"
            if aliases_file.exists():
                aliases_content = aliases_file.read_text()
                for line in aliases_content.strip().split("\n"):
                    if ":" in line:
                        alias, target = line.split(":", 1)
                        data["aliases"][alias] = target

            # Collect environment variables
            for env_file in pref_dir.glob("*.env"):
                wrapper_name = env_file.stem
                env_content = env_file.read_text().strip()
                if env_content:
                    env_vars = {}
                    for line in env_content.split("\n"):
                        if "=" in line:
                            key, value = line.split("=", 1)
                            env_vars[key] = value
                    if env_vars:
                        data["environment_variables"][wrapper_name] = env_vars

            # Write to export file
            Path(export_path).write_text(json.dumps(data, indent=2))

            self.log(f"Exported {len(data['preferences'])} preferences", "success")
            return True
        except Exception as e:
            self.log(f"Failed to export preferences: {e}", "error")
            return False

    def import_preferences(self, import_path: str) -> bool:
        """Import preferences and aliases from a file."""
        self.log(f"Importing preferences from {import_path}...")

        try:
            import json

            import_file = Path(import_path)
            if not import_file.exists():
                self.log(f"Import file not found: {import_path}", "error")
                return False

            data = json.loads(import_file.read_text())

            # Handle both old format (just prefs) and new format (prefs + aliases + env vars)
            if "preferences" in data:
                preferences = data["preferences"]
                aliases = data.get("aliases", {})
                environment_variables = data.get("environment_variables", {})
            else:
                # Old format - just preferences
                preferences = data
                aliases = {}
                environment_variables = {}

            # Apply each preference
            count = 0
            for wrapper_name, preference in preferences.items():
                if self.set_preference(wrapper_name, preference):
                    count += 1

            # Apply aliases
            if aliases:
                aliases_file = self.config_dir / "aliases"
                aliases_content = (
                    "\n".join(f"{k}:{v}" for k, v in aliases.items()) + "\n"
                )
                aliases_file.write_text(aliases_content)

            # Apply environment variables
            for wrapper_name, env_vars in environment_variables.items():
                env_file = self.config_dir / f"{wrapper_name}.env"
                env_content = "\n".join(f"{k}={v}" for k, v in env_vars.items()) + "\n"
                env_file.write_text(env_content)

            self.log(f"Imported {count} preferences", "success")
            return True
        except Exception as e:
            self.log(f"Failed to import preferences: {e}", "error")
            return False

    def set_pre_launch_script(self, wrapper_name: str, script_content: str) -> bool:
        """Set a pre-launch script for a wrapper."""
        self.log(f"Setting pre-launch script for {wrapper_name}...")

        script_dir = self.config_dir / "scripts" / wrapper_name
        script_dir.mkdir(parents=True, exist_ok=True)

        script_file = script_dir / "pre-launch.sh"

        try:
            script_file.write_text(script_content)
            script_file.chmod(0o755)
            self.log(f"Set pre-launch script for {wrapper_name}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to set pre-launch script: {e}", "error")
            return False

    def set_post_run_script(self, wrapper_name: str, script_content: str) -> bool:
        """Set post-run script for a wrapper."""
        self.log(f"Setting post-run script for {wrapper_name}...")

        script_dir = self.config_dir / "scripts" / wrapper_name
        script_dir.mkdir(parents=True, exist_ok=True)

        script_file = script_dir / "post-run.sh"

        try:
            script_file.write_text(script_content)
            script_file.chmod(0o755)
            self.log(f"Set post-run script for {wrapper_name}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to set post-run script: {e}", "error")
            return False

    # Safe integration test methods
    def install_app(self, app_id: str) -> bool:
        """Simulate app installation for testing."""
        self.log(f"Simulating installation of {app_id}")
        return True

    def enable_app(self, app_id: str) -> bool:
        """Simulate enabling app for testing."""
        self.log(f"Simulating enabling of {app_id}")
        return True

    def disable_app(self, app_id: str) -> bool:
        """Simulate disabling app for testing."""
        self.log(f"Simulating disabling of {app_id}")
        return True

    def update_app(self, app_id: str) -> bool:
        """Simulate updating app for testing."""
        self.log(f"Simulating update of {app_id}")
        return True

    def remove_app(self, app_id: str) -> bool:
        """Simulate removing app for testing."""
        self.log(f"Simulating removal of {app_id}")
        return True


def main() -> int | None:
    """Command-line interface for wrapper management."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Manage Flatpak application wrappers",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "command",
        choices=["list", "remove", "set-pref", "info", "discover", "cleanup"],
        help="Command to execute",
    )

    parser.add_argument("args", nargs="*", help="Command arguments")

    parser.add_argument("--config-dir", "-c", help="Configuration directory")

    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Enable verbose output",
    )

    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force operations without confirmation",
    )

    parser.add_argument(
        "--emit",
        action="store_true",
        help="Emit commands instead of executing (dry run)",
    )

    args = parser.parse_args()

    manager = WrapperManager(args.config_dir, args.verbose, args.emit)

    try:
        if args.command == "list":
            manager.display_wrappers()

        elif args.command == "remove":
            if not args.args:
                parser.error("remove requires a wrapper name")
            success = manager.remove_wrapper(args.args[0], args.force)
            return 0 if success else 1

        elif args.command == "set-pref":
            if len(args.args) != 2:
                parser.error(
                    "set-pref requires wrapper name and preference (system|flatpak)",
                )
            success = manager.set_preference(args.args[0], args.args[1])
            return 0 if success else 1

        elif args.command == "info":
            if not args.args:
                parser.error("info requires a wrapper name")
            success = manager.show_info(args.args[0])
            return 0 if success else 1

        elif args.command == "discover":
            manager.discover_features()

        elif args.command == "cleanup":
            removed_count = manager.cleanup_obsolete()
            manager.log(f"Cleaned up {removed_count} obsolete wrappers")

        return 0

    except Exception as e:
        if console:
            console.print(f"[red]Error:[/red] {e}")
        else:
            pass
        return 1


if __name__ == "__main__":
    sys.exit(main())
