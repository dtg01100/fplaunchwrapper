#!/usr/bin/env python3
"""Wrapper management functionality for fplaunchwrapper
Replaces fplaunch-manage bash script with Python implementation.
"""

from __future__ import annotations

import os
import sys
from pathlib import Path

if __name__ == "__main__":
    sys.path.insert(0, str(Path(__file__).parent.parent))

from rich.console import Console
from rich.table import Table

console = Console()
console_err = Console(stderr=True)

try:
    from lib.paths import get_default_config_dir, resolve_bin_dir
    from lib.safety import (
        get_wrapper_id,
        is_wrapper_file,
    )
except ImportError:
    from .paths import get_default_config_dir, resolve_bin_dir
    from .safety import (
        get_wrapper_id,
        is_wrapper_file,
    )


class WrapperManager:
    """Manages Flatpak application wrappers."""

    def __init__(
        self,
        config_dir: str | None = None,
        bin_dir: str | bool | None = None,
        verbose: bool = False,
        emit_mode: bool = False,
        emit_verbose: bool = False,
    ) -> None:
        if isinstance(bin_dir, bool):
            verbose, emit_mode, emit_verbose = bin_dir, verbose, emit_mode
            bin_dir = None

        self.verbose = verbose
        self.emit_mode = emit_mode
        self.emit_verbose = emit_verbose
        self.config_dir = Path(config_dir) if config_dir else get_default_config_dir()

        self.bin_dir = resolve_bin_dir(
            explicit_dir=bin_dir if isinstance(bin_dir, str) else None,
            config_dir=self.config_dir,
        )

        if not emit_mode:
            self.bin_dir.mkdir(parents=True, exist_ok=True)
            self.config_dir.mkdir(parents=True, exist_ok=True)

    def log(self, message: str, level: str = "info") -> None:
        """Log a message to stdout or stderr based on level.

        Error and warning messages go to stderr.
        Info and success messages go to stdout.
        Always prints regardless of verbose mode.
        """
        if level == "error":
            console_err.print(f"[red]ERROR:[/red] {message}")
        elif level == "warning":
            console_err.print(f"[yellow]WARN:[/yellow] {message}")
        elif level == "success":
            console.print(f"[green]âœ“[/green] {message}")
        elif level in ["info", "emit"]:
            console.print(message)
        else:
            console.print(message)

    def list_wrappers(self) -> list[dict[str, str]]:
        """List all installed wrappers."""
        wrappers: list[dict[str, str]] = []

        if not self.bin_dir.exists():
            return wrappers

        for item in self.bin_dir.iterdir():
            if item.is_file() and os.access(item, os.X_OK):
                if is_wrapper_file(str(item)):
                    wrapper_id = get_wrapper_id(str(item))
                    wrappers.append(
                        {
                            "name": item.name,
                            "path": str(item),
                            "id": wrapper_id or "unknown",
                        },
                    )
                else:
                    try:
                        content = item.read_text()
                        if "Generated by fplaunchwrapper" in content:
                            wrapper_id = "unknown"
                            for line in content.split("\n"):
                                if line.startswith('ID="') and line.endswith('"'):
                                    wrapper_id = line[4:-1]
                                    break
                            wrappers.append(
                                {
                                    "name": item.name,
                                    "path": str(item),
                                    "id": wrapper_id,
                                },
                            )
                    except (OSError, IOError, UnicodeDecodeError):
                        pass

        return wrappers

    def display_wrappers(self) -> None:
        """Display wrappers in a nice format."""
        wrappers = self.list_wrappers()

        if not wrappers:
            console.print("[yellow]No wrappers found[/yellow]")
            console.print(
                f"Run 'fplaunch generate {self.bin_dir}' to create wrappers",
            )
            return

        table = Table(title="Flatpak Wrappers")
        table.add_column("Wrapper", style="cyan", no_wrap=True)
        table.add_column("Flatpak ID", style="magenta")
        table.add_column("Path", style="dim")

        for wrapper in wrappers:
            table.add_row(wrapper["name"], wrapper["id"], wrapper["path"])

        console.print(table)
        console.print(f"\n[green]{len(wrappers)}[/green] wrappers found")

    def remove_wrapper(self, wrapper_name: str, force: bool = False) -> bool:
        """Remove a specific wrapper."""
        wrapper_path = self.bin_dir / wrapper_name

        if not wrapper_path.exists() and not self.emit_mode:
            self.log(f"Wrapper '{wrapper_name}' not found", "error")
            return False

        if not force and not self.emit_mode:
            from rich.prompt import Confirm

            if not Confirm.ask(
                f"Are you sure you want to remove wrapper '{wrapper_name}'?",
            ):
                console.print("[yellow]Removal cancelled[/yellow]")
                return False

        if self.emit_mode:
            self.log(f"EMIT: Would remove wrapper: {wrapper_name}")
            return True

        try:
            removed_any = False
            if wrapper_path.exists():
                try:
                    wrapper_path.unlink()
                    removed_any = True
                except Exception as e:
                    self.log(f"Failed to remove wrapper file: {e}", "warning")
            pref_file = self.config_dir / f"{wrapper_name}.pref"
            if pref_file.exists():
                try:
                    pref_file.unlink()
                    removed_any = True
                except Exception as e:
                    self.log(f"Failed to remove preference file: {e}", "warning")
            env_file = self.config_dir / f"{wrapper_name}.env"
            if env_file.exists():
                try:
                    env_file.unlink()
                    removed_any = True
                except Exception as e:
                    self.log(f"Failed to remove environment file: {e}", "warning")
            hooks_dir = self.config_dir / "scripts" / wrapper_name
            if hooks_dir.exists():
                import shutil

                try:
                    shutil.rmtree(hooks_dir)
                    removed_any = True
                except Exception as e:
                    self.log(f"Failed to remove hook scripts: {e}", "warning")

            aliases_file = self.config_dir / "aliases"
            if aliases_file.exists():
                try:
                    content = aliases_file.read_text()
                    new_lines = []
                    for line in content.splitlines():
                        line = line.strip()
                        if not line:
                            continue
                        if (
                            line.endswith(f":{wrapper_name}")
                            or line.split()[0] == wrapper_name
                        ):
                            continue
                        new_lines.append(line)
                    if new_lines:
                        aliases_file.write_text("\n".join(new_lines) + "\n")
                    else:
                        aliases_file.unlink()
                    removed_any = True
                except Exception as e:
                    self.log(f"Failed to update aliases file: {e}", "warning")

            if removed_any:
                self.log(
                    f"Removed wrapper and associated files: {wrapper_name}", "success"
                )
            else:
                self.log(f"No files removed for wrapper: {wrapper_name}", "info")

            return True
        except Exception as e:
            self.log(f"Failed to remove wrapper {wrapper_name}: {e}", "error")
            return False

    def set_preference(self, wrapper_name: str, preference: str) -> bool:
        """Set launch preference for a wrapper."""
        if (
            not wrapper_name
            or not isinstance(wrapper_name, str)
            or not wrapper_name.strip()
        ):
            self.log("Invalid wrapper name: must be a non-empty string", "error")
            return False

        if not preference or not isinstance(preference, str) or not preference.strip():
            self.log("Invalid preference: must be a non-empty string", "error")
            return False

        if preference not in ["system", "flatpak"]:
            import re

            if not re.match(r"^[A-Za-z0-9._-]+$", preference):
                self.log(
                    f"Invalid preference: {preference}. Use 'system', 'flatpak', or a valid Flatpak ID",
                    "error",
                )
                return False

        pref_file = self.config_dir / f"{wrapper_name}.pref"

        if self.emit_mode:
            self.log(f"EMIT: Would write '{preference}' to {pref_file}")

            if self.emit_verbose:
                self.log(f"EMIT: File content for {pref_file}:")
                from rich.panel import Panel

                console.print(
                    Panel.fit(
                        preference,
                        title=f"ðŸ“„ {wrapper_name}.pref preference file",
                        border_style="green",
                    ),
                )
                print(preference)

            return True
        try:
            pref_file.write_text(preference)
            self.log(
                f"Set preference for '{wrapper_name}' to '{preference}'",
                "success",
            )
            return True
        except Exception as e:
            self.log(f"Failed to set preference for '{wrapper_name}': {e}", "error")
            return False

    def get_preference(self, wrapper_name: str) -> str | None:
        """Get launch preference for a wrapper."""
        pref_file = self.config_dir / f"{wrapper_name}.pref"

        if pref_file.exists():
            try:
                return pref_file.read_text().strip()
            except Exception:
                pass

        return None

    def set_preference_all(self, preference: str) -> int:
        """Set preference for all wrappers."""
        if preference not in ["system", "flatpak"]:
            self.log(
                f"Invalid preference: {preference}. Use 'system' or 'flatpak'",
                "error",
            )
            return 0

        wrappers = self.list_wrappers()
        updated_count = 0

        for wrapper in wrappers:
            if self.set_preference(wrapper["name"], preference):
                updated_count += 1

        if updated_count > 0:
            self.log(
                f"Set preference to '{preference}' for {updated_count} wrappers",
                "success",
            )

        return updated_count

    def show_info(self, wrapper_name: str) -> bool:
        """Show detailed information about a wrapper."""
        wrapper_path = self.bin_dir / wrapper_name

        if not wrapper_path.exists():
            self.log(f"Wrapper '{wrapper_name}' not found", "error")
            return False

        wrapper_id = None
        preference = self.get_preference(wrapper_name)

        if is_wrapper_file(str(wrapper_path)):
            wrapper_id = get_wrapper_id(str(wrapper_path))

        info_lines = [
            f"Wrapper: {wrapper_name}",
            f"Path: {wrapper_path}",
            f"Flatpak ID: {wrapper_id or 'Unknown'}",
            f"Preference: {preference or 'Not set'}",
            f"Executable: {'Yes' if os.access(wrapper_path, os.X_OK) else 'No'}",
        ]

        from rich.panel import Panel

        console.print(
            Panel.fit(
                "\n".join(info_lines),
                title=f"Wrapper Information: {wrapper_name}",
            ),
        )

        return True

    def search_wrappers(self, query: str) -> None:
        """Search for wrappers matching a query."""
        wrappers = self.list_wrappers()
        matches = []

        query = query.lower()
        for wrapper in wrappers:
            if (
                query in wrapper["name"].lower()
                or query in wrapper["id"].lower()
                or query in wrapper["path"].lower()
            ):
                matches.append(wrapper)

        if matches:
            table = Table(title=f"Search Results for '{query}'")
            table.add_column("Wrapper", style="cyan", no_wrap=True)
            table.add_column("Flatpak ID", style="magenta")
            table.add_column("Path", style="dim")

            for wrapper in matches:
                table.add_row(wrapper["name"], wrapper["id"], wrapper["path"])

            console.print(table)
            console.print(
                f"\n[green]{len(matches)}[/green] match{'es' if len(matches) > 1 else ''} found"
            )
        else:
            console.print(f"[yellow]No wrappers found matching '{query}'[/yellow]")

    def list_managed_files(
        self, app_name: str | None = None, file_type: str | None = None
    ) -> dict[str, list[dict[str, str]]]:
        """List all managed files for wrappers.

        Args:
            app_name: Optional app name to filter files by
            file_type: Optional filter for file type ('wrappers', 'prefs', 'env', 'aliases', 'all')

        Returns:
            Dictionary with app names as keys and lists of file info as values
        """
        result = {}

        xdg_data_home = os.environ.get(
            "XDG_DATA_HOME", str(Path.home() / ".local" / "share")
        )
        data_dir = Path(xdg_data_home) / "fplaunchwrapper"

        if app_name:
            apps_to_check = [app_name]
        else:
            wrappers = self.list_wrappers()
            apps_to_check = [w["name"] for w in wrappers]

        for app in apps_to_check:
            files = []

            wrapper_path = self.bin_dir / app
            if wrapper_path.exists() and (
                file_type is None or file_type in ("wrappers", "all")
            ):
                files.append(
                    {
                        "type": "wrapper",
                        "path": str(wrapper_path),
                    }
                )

            pref_file = self.config_dir / f"{app}.pref"
            if pref_file.exists() and (
                file_type is None or file_type in ("prefs", "all")
            ):
                files.append(
                    {
                        "type": "preference",
                        "path": str(pref_file),
                    }
                )

            env_file = self.config_dir / f"{app}.env"
            if env_file.exists() and (file_type is None or file_type in ("env", "all")):
                files.append(
                    {
                        "type": "environment",
                        "path": str(env_file),
                    }
                )

            app_data_dir = data_dir / app
            if app_data_dir.exists() and (file_type is None or file_type in ("all")):
                files.append(
                    {
                        "type": "data",
                        "path": str(app_data_dir),
                    }
                )

            script_dir = self.config_dir / "scripts" / app
            if script_dir.exists():
                pre_launch = script_dir / "pre-launch.sh"
                post_run = script_dir / "post-run.sh"
                if pre_launch.exists():
                    files.append(
                        {
                            "type": "pre-launch",
                            "path": str(pre_launch),
                        }
                    )
                if post_run.exists():
                    files.append(
                        {
                            "type": "post-run",
                            "path": str(post_run),
                        }
                    )

            if files:
                result[app] = files

        if not app_name and (file_type is None or file_type in ("aliases", "all")):
            aliases_file = self.config_dir / "aliases"
            if aliases_file.exists():
                result["_aliases"] = [
                    {
                        "type": "aliases",
                        "path": str(aliases_file),
                    }
                ]

        return result

    def show_generated_files(self, app_name: str | None = None) -> None:
        """Show generated files for wrappers.

        Args:
            app_name: Optional app name to filter files by
        """
        if app_name:
            wrapper_path = self.bin_dir / app_name
            pref_file = self.config_dir / f"{app_name}.pref"
            env_file = self.config_dir / f"{app_name}.env"
            script_dir = self.config_dir / "scripts" / app_name
            pre_launch_script = script_dir / "pre-launch.sh"
            post_run_script = script_dir / "post-run.sh"

            files = []
            if wrapper_path.exists():
                files.append(("Wrapper", str(wrapper_path)))
            if pref_file.exists():
                files.append(("Preference", str(pref_file)))
            if env_file.exists():
                files.append(("Environment", str(env_file)))
            if pre_launch_script.exists():
                files.append(("Pre-launch Script", str(pre_launch_script)))
            if post_run_script.exists():
                files.append(("Post-run Script", str(post_run_script)))

            if files:
                from rich.panel import Panel
                from rich.table import Table

                table = Table()
                table.add_column("Type", style="cyan")
                table.add_column("Path", style="white")

                for file_type, file_path in files:
                    table.add_row(file_type, file_path)

                console.print(Panel.fit(table, title=f"Generated Files: {app_name}"))
            else:
                console.print(
                    f"[yellow]No generated files found for {app_name}[/yellow]"
                )
        else:
            from rich.table import Table

            wrappers = self.list_wrappers()
            all_files = []

            for wrapper in wrappers:
                wrapper_path = self.bin_dir / wrapper["name"]
                if wrapper_path.exists():
                    all_files.append(("Wrapper", str(wrapper_path)))

                pref_file = self.config_dir / f"{wrapper['name']}.pref"
                if pref_file.exists():
                    all_files.append(("Preference", str(pref_file)))

                env_file = self.config_dir / f"{wrapper['name']}.env"
                if env_file.exists():
                    all_files.append(("Environment", str(env_file)))

                script_dir = self.config_dir / "scripts" / wrapper["name"]
                pre_launch_script = script_dir / "pre-launch.sh"
                if pre_launch_script.exists():
                    all_files.append(("Pre-launch Script", str(pre_launch_script)))

                post_run_script = script_dir / "post-run.sh"
                if post_run_script.exists():
                    all_files.append(("Post-run Script", str(post_run_script)))

            if all_files:
                from rich.table import Table

                table = Table(title="All Generated Files")
                table.add_column("Type", style="cyan")
                table.add_column("Path", style="white")

                for file_type, file_path in all_files:
                    table.add_row(file_type, file_path)

                console.print(table)
                console.print(
                    f"\n[green]{len(all_files)}[/green] generated file{'s' if len(all_files) > 1 else ''} found"
                )
            else:
                console.print("[yellow]No generated files found[/yellow]")

    def discover_features(self) -> None:
        """Discover and show available features."""
        features = [
            (
                "Wrapper Generation",
                "Automatically create launch scripts for Flatpak apps",
            ),
            ("Launch Preferences", "Choose between system packages and Flatpak apps"),
            ("Automatic Updates", "Monitor for app changes and update wrappers"),
            ("Interactive Mode", "Choose launch method interactively"),
            ("Script Integration", "Pre/post-launch scripts for customization"),
            ("Alias Support", "Create custom aliases for wrappers"),
            ("Configuration", "TOML-based configuration with validation"),
        ]

        from rich.table import Table as RichTable

        table = RichTable(title="fplaunchwrapper Features")
        table.add_column("Feature", style="cyan", no_wrap=True)
        table.add_column("Description", style="white")

        for feature, description in features:
            table.add_row(feature, description)

        console.print(table)

        console.print("\n[bold]Usage Examples:[/bold]")
        examples = [
            "fplaunch generate ~/bin          # Generate wrappers",
            "fplaunch list                     # List all wrappers",
            "fplaunch set-pref firefox flatpak # Set preference",
            "fplaunch monitor                  # Monitor for changes",
            "firefox --fpwrapper-help          # Wrapper help",
        ]

        for example in examples:
            console.print(f"  [green]$[/green] {example}")

    def cleanup_obsolete(self) -> int:
        """Clean up wrappers for uninstalled applications."""
        self.log("Cleaning up obsolete wrappers...")

        try:
            from .generate import WrapperGenerator

            gen = WrapperGenerator(
                str(self.bin_dir), self.verbose, self.emit_mode, self.emit_verbose
            )
            installed_apps = gen.get_installed_flatpaks()
        except (ImportError, RuntimeError) as e:
            self.log(f"Could not get installed Flatpak apps: {e}", "warning")
            return 0

        removed_count = 0

        if not self.bin_dir.exists():
            return 0

        for item in self.bin_dir.iterdir():
            if not item.is_file():
                continue

            remove_item = False

            try:
                from .safety import get_wrapper_id, is_wrapper_file

                if is_wrapper_file(str(item)):
                    wrapper_id = get_wrapper_id(str(item))
                    if wrapper_id and wrapper_id not in installed_apps:
                        remove_item = True
            except Exception:
                pass

            if remove_item:
                if self.emit_mode:
                    self.log(f"EMIT: Would remove obsolete wrapper: {item.name}")
                    removed_count += 1
                else:
                    try:
                        item.unlink()
                        self.log(f"Removed obsolete wrapper: {item.name}", "success")
                        removed_count += 1

                        pref_file = self.config_dir / f"{item.name}.pref"
                        if pref_file.exists():
                            pref_file.unlink()

                        aliases_file = self.config_dir / "aliases"
                        if aliases_file.exists():
                            try:
                                content = aliases_file.read_text()
                                new_content = "\n".join(
                                    line
                                    for line in content.split("\n")
                                    if not line.startswith(f"{item.name} ")
                                )
                                if new_content.strip():
                                    aliases_file.write_text(new_content)
                                else:
                                    aliases_file.unlink()
                            except Exception as e:
                                self.log(
                                    f"Warning: Could not clean up aliases: {e}",
                                    "warning",
                                )
                    except Exception as e:
                        self.log(
                            f"Failed to remove obsolete wrapper {item.name}: {e}",
                            "error",
                        )

        if removed_count > 0:
            self.log(f"Cleaned up {removed_count} obsolete wrapper(s)", "success")
        else:
            self.log("No obsolete wrappers found")

        return removed_count

    def _resolve_alias_chain(
        self, alias_name: str, aliases: dict[str, str]
    ) -> list[str]:
        """Resolve an alias to its final target, following all alias chains.

        Args:
            alias_name: The alias to resolve
            aliases: Dictionary of existing aliases

        Returns:
            List representing the alias chain (including the starting alias)

        Raises:
            RuntimeError: If a circular reference is detected
        """
        chain = []
        current = alias_name

        while current:
            if current in chain:
                chain.append(current)
                cycle_str = " -> ".join(chain)
                raise RuntimeError(f"Circular alias reference detected: {cycle_str}")

            chain.append(current)

            if current not in aliases:
                break

            current = aliases[current]

        return chain

    def _check_system_command_collision(self, name: str) -> bool:
        """Check if a name collides with a system command available in PATH.

        Args:
            name: The name to check

        Returns:
            True if name collides with a system command, False otherwise
        """
        import shutil

        return shutil.which(name) is not None

    def _check_collision(self, alias_name: str) -> str | None:
        """Check for namespace collisions with existing wrappers, aliases, or system commands.

        Args:
            alias_name: The alias name to check for collisions

        Returns:
            Collision type as string if collision detected, None otherwise
        """
        wrapper_path = self.bin_dir / alias_name
        if wrapper_path.exists():
            return "wrapper"

        if self._check_system_command_collision(alias_name):
            return "system_command"

        return None

    def create_alias(
        self, alias_name: str, target_wrapper: str, validate_target: bool = False
    ) -> bool:
        """Create an alias for a wrapper with comprehensive collision detection and validation.

        Args:
            alias_name: Name of the alias to create
            target_wrapper: Name of the target wrapper to alias to
            validate_target: If True, verify target wrapper exists (default: False for flexibility)

        Validates that:
        - The alias name doesn't collide with existing wrappers
        - The alias name doesn't collide with system commands
        - The alias name doesn't already exist
        - The alias doesn't create a circular reference
        - Optionally checks that the target wrapper exists
        """
        self.log(f"Creating alias '{alias_name}' -> '{target_wrapper}'...")

        if not alias_name or not isinstance(alias_name, str) or not alias_name.strip():
            self.log("Invalid alias name: must be a non-empty string", "error")
            return False

        if (
            not target_wrapper
            or not isinstance(target_wrapper, str)
            or not target_wrapper.strip()
        ):
            self.log("Invalid target wrapper: must be a non-empty string", "error")
            return False

        aliases_file = self.config_dir / "aliases"

        try:
            collision_type = self._check_collision(alias_name)
            if collision_type:
                if collision_type == "wrapper":
                    self.log(
                        f"Error: Alias name '{alias_name}' collides with an existing wrapper",
                        "error",
                    )
                elif collision_type == "system_command":
                    self.log(
                        f"Error: Alias name '{alias_name}' collides with a system command",
                        "error",
                    )
                    return False

            if validate_target:
                target_path = self.bin_dir / target_wrapper
                if not target_path.exists():
                    self.log(
                        f"Error: Target wrapper '{target_wrapper}' not found", "error"
                    )
                    return False

            if aliases_file.exists():
                aliases_content = aliases_file.read_text()
                aliases = dict(
                    line.split(":", 1)
                    for line in aliases_content.strip().split("\n")
                    if ":" in line and len(line.split(":", 1)) == 2
                )
            else:
                aliases = {}

            if alias_name in aliases:
                self.log(
                    f"Error: Alias '{alias_name}' already exists -> '{aliases[alias_name]}'",
                    "error",
                )
                return False

            temp_aliases = aliases.copy()
            temp_aliases[alias_name] = target_wrapper

            try:
                self._resolve_alias_chain(alias_name, temp_aliases)
            except RuntimeError as e:
                self.log(f"Error: {e}", "error")
                return False

            if target_wrapper in aliases:
                try:
                    target_chain = self._resolve_alias_chain(target_wrapper, aliases)
                    chain_str = " -> ".join([alias_name] + target_chain[1:])
                    self.log(f"Info: Complete alias chain will be: {chain_str}", "info")
                except Exception as e:
                    self.log(
                        f"Warning: Could not resolve target alias chain: {e}", "warning"
                    )

            aliases[alias_name] = target_wrapper

            if self.emit_mode:
                self.log(
                    f"EMIT: Would write alias '{alias_name}' -> '{target_wrapper}' to {aliases_file}"
                )
            else:
                aliases_file.write_text(
                    "\n".join(f"{k}:{v}" for k, v in sorted(aliases.items())) + "\n"
                )

            self.log(f"Created alias: {alias_name} -> {target_wrapper}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to create alias: {e}", "error")
            return False

    def block_app(self, app_id: str) -> bool:
        """Add an application to the blocklist."""
        self.log(f"Blocking application: {app_id}...")

        blocklist_file = self.config_dir / "blocklist"

        try:
            if blocklist_file.exists():
                blocklist = set(blocklist_file.read_text().strip().split("\n"))
            else:
                blocklist = set()

            if app_id in blocklist:
                self.log(f"Application '{app_id}' already blocked", "warning")
                return True

            blocklist.add(app_id)
            blocklist_file.write_text("\n".join(sorted(blocklist)) + "\n")

            self.log(f"Blocked application: {app_id}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to block application: {e}", "error")
            return False

    def unblock_app(self, app_id: str) -> bool:
        """Remove an application from the blocklist."""
        self.log(f"Unblocking application: {app_id}...")

        blocklist_file = self.config_dir / "blocklist"

        try:
            if not blocklist_file.exists():
                self.log(f"Application '{app_id}' not in blocklist", "warning")
                return True

            blocklist = set(blocklist_file.read_text().strip().split("\n"))

            if app_id not in blocklist:
                self.log(f"Application '{app_id}' not in blocklist", "warning")
                return True

            blocklist.remove(app_id)
            if blocklist:
                blocklist_file.write_text("\n".join(sorted(blocklist)) + "\n")
            else:
                blocklist_file.unlink()

            self.log(f"Unblocked application: {app_id}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to unblock application: {e}", "error")
            return False

    def set_environment_variable(
        self, wrapper_name: str, var_name: str, var_value: str
    ) -> bool:
        """Set an environment variable for a wrapper."""
        self.log(f"Setting {var_name}={var_value} for {wrapper_name}...")

        env_file = self.config_dir / f"{wrapper_name}.env"

        try:
            if env_file.exists():
                content = env_file.read_text()
                lines = content.strip().split("\n")
            else:
                lines = []

            found = False
            for i, line in enumerate(lines):
                if line.startswith(f"{var_name}="):
                    lines[i] = f"{var_name}={var_value}"
                    found = True
                    break

            if not found:
                lines.append(f"{var_name}={var_value}")

            env_file.write_text("\n".join(lines) + "\n" if lines else "")

            self.log(f"Set environment variable: {var_name}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to set environment variable: {e}", "error")
            return False

    def export_preferences(self, export_path: str) -> bool:
        """Export preferences and aliases to a file."""
        self.log(f"Exporting preferences to {export_path}...")

        try:
            import json

            data: dict = {"preferences": {}, "aliases": {}, "environment_variables": {}}
            pref_dir = self.config_dir

            for pref_file in pref_dir.glob("*.pref"):
                wrapper_name = pref_file.stem
                preference = pref_file.read_text().strip()
                data["preferences"][wrapper_name] = preference

            aliases_file = self.config_dir / "aliases"
            if aliases_file.exists():
                aliases_content = aliases_file.read_text()
                for line in aliases_content.strip().split("\n"):
                    if ":" in line:
                        alias, target = line.split(":", 1)
                        data["aliases"][alias] = target

            for env_file in pref_dir.glob("*.env"):
                wrapper_name = env_file.stem
                env_content = env_file.read_text().strip()
                if env_content:
                    env_vars = {}
                    for line in env_content.split("\n"):
                        if "=" in line:
                            key, value = line.split("=", 1)
                            env_vars[key] = value
                    if env_vars:
                        data["environment_variables"][wrapper_name] = env_vars

            Path(export_path).write_text(json.dumps(data, indent=2))

            self.log(f"Exported {len(data['preferences'])} preferences", "success")
            return True
        except Exception as e:
            self.log(f"Failed to export preferences: {e}", "error")
            return False

    def import_preferences(self, import_path: str) -> bool:
        """Import preferences and aliases from a file."""
        self.log(f"Importing preferences from {import_path}...")

        try:
            import json

            import_file = Path(import_path)
            if not import_file.exists():
                self.log(f"Import file not found: {import_path}", "error")
                return False

            data = json.loads(import_file.read_text())

            # Handle both old format (just prefs) and new format (prefs + aliases + env vars)
            if "preferences" in data:
                preferences = data["preferences"]
                aliases = data.get("aliases", {})
                environment_variables = data.get("environment_variables", {})
            else:
                # Old format - just preferences
                preferences = data
                aliases = {}
                environment_variables = {}

            count = 0
            for wrapper_name, preference in preferences.items():
                if self.set_preference(wrapper_name, preference):
                    count += 1

            if aliases:
                aliases_file = self.config_dir / "aliases"
                aliases_content = (
                    "\n".join(f"{k}:{v}" for k, v in aliases.items()) + "\n"
                )
                aliases_file.write_text(aliases_content)

            for wrapper_name, env_vars in environment_variables.items():
                env_file = self.config_dir / f"{wrapper_name}.env"
                env_content = "\n".join(f"{k}={v}" for k, v in env_vars.items()) + "\n"
                env_file.write_text(env_content)

            self.log(f"Imported {count} preferences", "success")
            return True
        except Exception as e:
            self.log(f"Failed to import preferences: {e}", "error")
            return False

    def set_pre_launch_script(self, wrapper_name: str, script_content: str) -> bool:
        """Set a pre-launch script for a wrapper."""
        self.log(f"Setting pre-launch script for {wrapper_name}...")

        script_dir = self.config_dir / "scripts" / wrapper_name
        script_dir.mkdir(parents=True, exist_ok=True)

        script_file = script_dir / "pre-launch.sh"

        try:
            script_file.write_text(script_content)
            script_file.chmod(0o755)
            self.log(f"Set pre-launch script for {wrapper_name}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to set pre-launch script: {e}", "error")
            return False

    def set_post_run_script(self, wrapper_name: str, script_content: str) -> bool:
        """Set post-run script for a wrapper."""
        self.log(f"Setting post-run script for {wrapper_name}...")

        script_dir = self.config_dir / "scripts" / wrapper_name
        script_dir.mkdir(parents=True, exist_ok=True)

        script_file = script_dir / "post-run.sh"

        try:
            script_file.write_text(script_content)
            script_file.chmod(0o755)
            self.log(f"Set post-run script for {wrapper_name}", "success")
            return True
        except Exception as e:
            self.log(f"Failed to set post-run script: {e}", "error")
            return False

    # Safe integration test methods
    def install_app(self, app_id: str) -> bool:
        """Simulate app installation for testing."""
        self.log(f"Simulating installation of {app_id}")
        return True

    def enable_app(self, app_id: str) -> bool:
        """Simulate enabling app for testing."""
        self.log(f"Simulating enabling of {app_id}")
        return True

    def disable_app(self, app_id: str) -> bool:
        """Simulate disabling app for testing."""
        self.log(f"Simulating disabling of {app_id}")
        return True

    def update_app(self, app_id: str) -> bool:
        """Simulate updating app for testing."""
        self.log(f"Simulating update of {app_id}")
        return True

    def remove_app(self, app_id: str) -> bool:
        """Simulate removing app for testing."""
        self.log(f"Simulating removal of {app_id}")
        return True


def main() -> int | None:
    """Command-line interface for wrapper management."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Manage Flatpak application wrappers",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "command",
        choices=[
            "list",
            "remove",
            "rm",
            "set-pref",
            "info",
            "discover",
            "search",
            "cleanup",
        ],
        help="Command to execute",
    )

    parser.add_argument("args", nargs="*", help="Command arguments")

    parser.add_argument("--config-dir", "-c", help="Configuration directory")

    parser.add_argument(
        "--verbose",
        "-v",
        action="store_true",
        help="Enable verbose output",
    )

    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force operations without confirmation",
    )

    parser.add_argument(
        "--emit",
        action="store_true",
        help="Emit commands instead of executing (dry run)",
    )

    args = parser.parse_args()

    manager = WrapperManager(args.config_dir, args.verbose, args.emit)

    command = args.command
    if command == "search":
        command = "discover"
    elif command == "rm":
        command = "remove"

    try:
        if command == "list":
            manager.display_wrappers()

        elif command == "remove":
            if not args.args:
                parser.error("remove requires a wrapper name")
            success = manager.remove_wrapper(args.args[0], args.force)
            return 0 if success else 1

        elif command == "set-pref":
            if len(args.args) != 2:
                parser.error(
                    "set-pref requires wrapper name and preference (system|flatpak)",
                )
            success = manager.set_preference(args.args[0], args.args[1])
            return 0 if success else 1

        elif command == "info":
            if not args.args:
                parser.error("info requires a wrapper name")
            success = manager.show_info(args.args[0])
            return 0 if success else 1

        elif command == "discover":
            manager.discover_features()

        elif command == "cleanup":
            removed_count = manager.cleanup_obsolete()
            manager.log(f"Cleaned up {removed_count} obsolete wrappers")

        return 0

    except Exception as e:
        console.print(f"[red]Error:[/red] {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
