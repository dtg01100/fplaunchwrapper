#!/usr/bin/env python3
"""Robust Python utilities for fplaunchwrapper
This script provides secure implementations of critical operations.
"""

from __future__ import annotations

import contextlib
import hashlib
import os
import re
import sys
import tempfile
import unicodedata
from pathlib import Path
from typing import Any

try:
    from platformdirs import user_config_dir, user_data_dir
except ImportError:
    from typing import Union, Literal
    # Fallback implementation with matching signatures
    def user_config_dir(
        appname: str | None = None,
        appauthor: Union[str, Literal[False], None] = None,
        version: str | None = None,
        roaming: bool = False,
        ensure_exists: bool = True,
    ) -> str:
        return os.path.expanduser(f"~/.config/{appname}")

    def user_data_dir(
        appname: str | None = None,
        appauthor: Union[str, Literal[False], None] = None,
        version: str | None = None,
        roaming: bool = False,
        ensure_exists: bool = True,
    ) -> str:
        return os.path.expanduser(f"~/.local/share/{appname}")


def sanitize_string(input_str: str) -> str:
    """Safely sanitize a string for use in Python code."""
    if not input_str:
        return ""

    sanitized = input_str.replace("\\", "\\\\")
    sanitized = sanitized.replace('"', '\\"')
    sanitized = sanitized.replace("'", "\\'")
    sanitized = sanitized.replace("$", "\\$")
    sanitized = sanitized.replace("`", "\\`")
    sanitized = sanitized.replace("(", "\\(")
    sanitized = sanitized.replace(")", "\\)")
    sanitized = sanitized.replace(";", "\\;")
    sanitized = sanitized.replace("&", "\\&")
    sanitized = sanitized.replace("|", "\\|")
    sanitized = sanitized.replace("<", "\\<")
    sanitized = sanitized.replace(">", "\\>")
    sanitized = sanitized.replace("\n", "\\n")
    sanitized = sanitized.replace("\r", "\\r")
    return sanitized.replace("\t", "\\t")


def canonicalize_path_no_resolve(path: str | Path) -> Path | None:
    """Normalize a path without resolving symlinks."""
    try:
        path_str = str(path)

        if path_str.startswith("~"):
            path_str = os.path.expanduser(path_str)

        if not os.path.isabs(path_str):
            path_str = os.path.abspath(path_str)

        return Path(os.path.normpath(path_str))

    except (TypeError, ValueError, OSError):
        return None


def validate_home_dir(dir_path: str | Path) -> str | None:
    """Validate that a directory is within HOME.

    Returns the normalized absolute path string if the directory is within the user's HOME,
    otherwise returns None. Accepts string or Path-like input.
    """
    try:
        dir_str = str(dir_path)

        if dir_str.startswith("~"):
            dir_str = os.path.expanduser(dir_str)

        abs_dir = os.path.abspath(dir_str)

        if os.path.islink(abs_dir):
            abs_dir = os.path.realpath(abs_dir)

        home = os.path.expanduser("~")
        if abs_dir == home or abs_dir.startswith(home + os.sep):
            return abs_dir

        return None
    except (TypeError, ValueError, OSError):
        return None


def is_wrapper_file(file_path: str | Path) -> bool | None:
    """Check if a file is a valid wrapper script."""
    try:
        if not os.path.isfile(file_path):
            return False
        if not os.access(file_path, os.R_OK):
            return False
        if os.path.islink(file_path):
            return False

        size = os.path.getsize(file_path)
        if size > 100000:  # 100KB limit
            return False

        with open(file_path, encoding="utf-8", errors="ignore") as f:
            content = f.read(min(8192, size))

        if any(ord(c) < 32 and c not in "\t\n\r" for c in content):
            return False

        if not re.match(r"^#!.*(bash|sh)", content, re.MULTILINE):
            return False

        if "Generated by fplaunchwrapper" not in content:
            return False

        name_match = re.search(r"^NAME=[^\n]*", content, re.MULTILINE)
        id_match = re.search(r"^ID=[^\n]*", content, re.MULTILINE)

        if not name_match or not id_match:
            return False

        id_value = re.search(r'ID="([^"]*)"', id_match.group())
        return not (
            not id_value or not re.match(r"^[A-Za-z0-9._-]+$", id_value.group(1))
        )
    except (IOError, OSError, UnicodeDecodeError, re.error):
        return False


def get_wrapper_id(file_path: str | Path) -> str | None:
    """Extract the wrapper ID from a wrapper script.

    Returns the ID string when found, otherwise returns None.
    """
    try:
        with open(file_path, encoding="utf-8", errors="ignore") as f:
            content = f.read(8192)

        id_match = re.search(r'^ID="([^"]*)"', content, re.MULTILINE)
        if id_match:
            return id_match.group(1)

        comment_match = re.search(r"Flatpak ID:\s*([^\s\n]+)", content)
        if comment_match:
            return comment_match.group(1)

        return None
    except (IOError, OSError, UnicodeDecodeError, re.error):
        return None


def sanitize_id_to_name(id_str: str) -> str:
    """Sanitize a Flatpak ID to a safe name."""
    try:
        name = id_str.split(".")[-1].lower()

        try:
            name = unicodedata.normalize("NFKD", name)
            name = "".join(c for c in name if not unicodedata.combining(c))
        except ImportError:
            pass

        with contextlib.suppress(UnicodeError):
            name = name.encode("ascii", "ignore").decode("ascii")

        name = re.sub(r"[^a-z0-9_\-]", "-", name)

        name = re.sub(r"^\-+|\-+$", "", name)
        name = re.sub(r"\-+", "-", name)

        if not name:
            hash_obj = hashlib.sha256(id_str.encode("utf-8"))
            name = f"app-{hash_obj.hexdigest()[:8]}"

        return name[:100]

    except (TypeError, AttributeError, UnicodeDecodeError, re.error):
        try:
            return f"app-{hashlib.sha256(id_str.encode('utf-8')).hexdigest()[:8]}"
        except Exception:
            return "app-fallback"


def find_executable(cmd: str) -> str | None:
    """Find an executable in PATH with security checks."""
    try:
        if "/" in cmd:
            if os.path.isfile(cmd) and os.access(cmd, os.X_OK):
                return os.path.abspath(cmd)
            return None

        for path_dir in os.getenv("PATH", "").split(":"):
            if not path_dir:
                continue
            exe_path = os.path.join(path_dir, cmd)
            if os.path.isfile(exe_path) and os.access(exe_path, os.X_OK):
                return os.path.abspath(exe_path)

        return None
    except (TypeError, OSError, AttributeError):
        return None


def safe_mktemp(
    template: str = "tmp.XXXXXX", dir_param: str | None = None
) -> str | None:
    """Create a secure temporary file.

    Returns the created temporary file path, or None on failure.
    """
    try:
        if dir_param and os.path.isdir(dir_param):
            tdir = dir_param
        else:
            for temp_dir in [
                os.getenv("TMPDIR"),
                os.getenv("TMP"),
                os.getenv("TEMP"),
                "/tmp",
            ]:
                if temp_dir and os.path.isdir(temp_dir):
                    tdir = temp_dir
                    break
            else:
                tdir = "/tmp"

        fd, path = tempfile.mkstemp(
            prefix=template.replace("XXXXXX", ""),
            dir=tdir,
            suffix="" if "XXXXXX" not in template else Path(template).suffix,
        )
        os.close(fd)
        return path
    except (IOError, OSError, ValueError):
        return None


def acquire_lock(lock_name: str = "fplaunch", timeout_seconds: float = 30) -> bool | None:
    """Acquire a file-based lock with timeout."""
    try:
        from pathlib import Path

        config_dir = Path.home() / ".config" / "fplaunchwrapper"
        config_dir.mkdir(parents=True, exist_ok=True)

        lock_dir = config_dir / "locks"
        lock_dir.mkdir(parents=True, exist_ok=True)

        lockfile = lock_dir / f"{lock_name}.lock"
        pidfile = lock_dir / f"{lock_name}.pid"

        import time

        start_time = time.time()
        end_time = start_time + timeout_seconds

        while time.time() < end_time:
            try:
                lockfile.mkdir(parents=True, exist_ok=False)
                pidfile.write_text(str(os.getpid()))
                return True
            except FileExistsError:
                time.sleep(0.1)
                continue

        return False  # Timeout

    except (IOError, OSError, PermissionError, RuntimeError):
        return False


def release_lock(lock_name: str = "fplaunch") -> bool | None:
    """Release a file-based lock."""
    try:
        from pathlib import Path

        config_dir = Path.home() / ".config" / "fplaunchwrapper"
        lock_dir = config_dir / "locks"
        lockfile = lock_dir / f"{lock_name}.lock"
        pidfile = lock_dir / f"{lock_name}.pid"

        if pidfile.exists():
            stored_pid = pidfile.read_text().strip()
            if stored_pid == str(os.getpid()):
                import shutil

                with contextlib.suppress(FileNotFoundError):
                    shutil.rmtree(lockfile)
                with contextlib.suppress(FileNotFoundError):
                    pidfile.unlink()
                return True

        return False

    except (IOError, OSError, PermissionError):
        return False


def get_temp_dir() -> str:
    """Get the best available temporary directory."""
    for temp_dir in [
        os.getenv("TMPDIR"),
        os.getenv("TMP"),
        os.getenv("TEMP"),
        os.path.join(os.path.expanduser("~"), ".cache"),
        "/var/tmp",
        "/tmp",
    ]:
        if temp_dir and os.path.isdir(temp_dir) and os.access(temp_dir, os.W_OK):
            return temp_dir

    return "/tmp"


if __name__ == "__main__":
    # Command line interface for testing
    if len(sys.argv) < 2:
        sys.exit(1)

    operation = sys.argv[1]

    if operation == "canonicalize_path":
        if len(sys.argv) != 3:
            sys.exit(1)
        result: Any = canonicalize_path_no_resolve(sys.argv[2])
    elif operation == "validate_home":
        if len(sys.argv) != 3:
            sys.exit(1)
        result = validate_home_dir(sys.argv[2])
    elif operation == "sanitize_name":
        if len(sys.argv) != 3:
            sys.exit(1)
        result = sanitize_id_to_name(sys.argv[2])
    elif operation == "find_executable":
        if len(sys.argv) != 3:
            sys.exit(1)
        result = find_executable(sys.argv[2])
    elif operation == "is_wrapper_file":
        if len(sys.argv) != 3:
            sys.exit(1)
        result = is_wrapper_file(sys.argv[2])
    elif operation == "get_wrapper_id":
        if len(sys.argv) != 3:
            sys.exit(1)
        result = get_wrapper_id(sys.argv[2])
    elif operation == "safe_mktemp":
        if len(sys.argv) < 3:
            sys.exit(1)
        result = safe_mktemp(sys.argv[2], sys.argv[3] if len(sys.argv) > 3 else None)
    else:
        sys.exit(1)
