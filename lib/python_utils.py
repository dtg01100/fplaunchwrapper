#!/usr/bin/env python3
"""
Robust Python utilities for fplaunchwrapper
This script provides secure implementations of critical operations
"""

import os
import sys
import re
import hashlib
import tempfile
import shlex
import unicodedata
from pathlib import Path

try:
    from platformdirs import user_config_dir, user_data_dir
except ImportError:
    # Fallback implementation
    def user_config_dir(appname):
        return os.path.expanduser(f"~/.config/{appname}")

    def user_data_dir(appname):
        return os.path.expanduser(f"~/.local/share/{appname}")


def sanitize_string(input_str):
    """Safely sanitize a string for use in Python code"""
    if not input_str:
        return ""

    # Escape backslashes and quotes
    sanitized = input_str.replace("\\", "\\\\")
    sanitized = sanitized.replace('"', '\\"')
    sanitized = sanitized.replace("'", "\\'")
    sanitized = sanitized.replace("$", "\\$")
    sanitized = sanitized.replace("`", "\\`")
    sanitized = sanitized.replace("(", "\\(")
    sanitized = sanitized.replace(")", "\\)")
    sanitized = sanitized.replace(";", "\\;")
    sanitized = sanitized.replace("&", "\\&")
    sanitized = sanitized.replace("|", "\\|")
    sanitized = sanitized.replace("<", "\\<")
    sanitized = sanitized.replace(">", "\\>")
    sanitized = sanitized.replace("\n", "\\n")
    sanitized = sanitized.replace("\r", "\\r")
    sanitized = sanitized.replace("\t", "\\t")

    return sanitized


def canonicalize_path_no_resolve(path):
    """Normalize a path without resolving symlinks"""
    try:
        # Expand tilde
        if path.startswith("~"):
            path = os.path.expanduser(path)

        # Make absolute if relative
        if not os.path.isabs(path):
            path = os.path.abspath(path)

        # Collapse '.' and '..' without resolving symlinks
        path = os.path.normpath(path)

        return path
    except Exception as e:
        print(f"Path normalization failed: {e}", file=sys.stderr)
        return None


def validate_home_dir(dir_path):
    """Validate that a directory is within HOME"""
    try:
        # Expand tilde
        if dir_path.startswith("~"):
            dir_path = os.path.expanduser(dir_path)

        # Get absolute path
        abs_dir = os.path.abspath(dir_path)

        # Resolve symlinks safely
        if os.path.islink(abs_dir):
            abs_dir = os.path.realpath(abs_dir)

        # Check if within HOME
        home = os.path.expanduser("~")
        if abs_dir == home or abs_dir.startswith(home + os.sep):
            return abs_dir

        return None
    except Exception as e:
        print(f"Home directory validation failed: {e}", file=sys.stderr)
        return None


def is_wrapper_file(file_path):
    """Check if a file is a valid wrapper script"""
    try:
        # Basic validation
        if not os.path.isfile(file_path):
            return False
        if not os.access(file_path, os.R_OK):
            return False
        if os.path.islink(file_path):
            return False

        # Check file size limits
        size = os.path.getsize(file_path)
        if size > 100000:  # 100KB limit
            return False

        # Read file content with proper encoding
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            content = f.read(min(8192, size))

        # Check for binary content
        if any(ord(c) < 32 and c not in "\t\n\r" for c in content):
            return False

        # Check shebang
        if not re.match(r"^#!.*(bash|sh)", content, re.MULTILINE):
            return False

        # Check for marker
        if "Generated by fplaunchwrapper" not in content:
            return False

        # Check for NAME and ID
        name_match = re.search(r"^NAME=[^\n]*", content)
        id_match = re.search(r"^ID=[^\n]*", content)

        if not name_match or not id_match:
            return False

        # Validate ID format
        id_value = re.search(r'ID="([^"]*)"', id_match.group())
        if not id_value or not re.match(r"^[A-Za-z0-9._-]+$", id_value.group(1)):
            return False

        return True
    except Exception as e:
        print(f"Wrapper file validation failed: {e}", file=sys.stderr)
        return False


def get_wrapper_id(file_path):
    """Extract the wrapper ID from a wrapper script"""
    try:
        # Read file content with proper encoding
        with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
            content = f.read(8192)

        # Try standard ID format first
        id_match = re.search(r'^ID="([^"]*)"', content, re.MULTILINE)
        if id_match:
            return id_match.group(1)

        # Fallback to comment extraction
        comment_match = re.search(r"Flatpak ID:\s*([^\s\n]+)", content)
        if comment_match:
            return comment_match.group(1)

        return None
    except Exception as e:
        print(f"Wrapper ID extraction failed: {e}", file=sys.stderr)
        return None


def sanitize_id_to_name(id_str):
    """Sanitize a Flatpak ID to a safe name"""
    try:
        # Extract last component after dots
        name = id_str.split(".")[-1].lower()

        # Unicode normalization and transliteration
        try:
            # Normalize to NFKD and remove diacritics
            name = unicodedata.normalize("NFKD", name)
            name = "".join(c for c in name if not unicodedata.combining(c))
        except ImportError:
            pass

        # Convert to ASCII if possible
        try:
            name = name.encode("ascii", "ignore").decode("ascii")
        except UnicodeError:
            pass

        # Replace non-alphanumeric characters with hyphens
        name = re.sub(r"[^a-z0-9_\-]", "-", name)

        # Remove leading/trailing hyphens and multiple hyphens
        name = re.sub(r"^\-+|\-+$", "", name)
        name = re.sub(r"\-+", "-", name)

        # Ensure not empty
        if not name:
            # Generate hash-based fallback
            hash_obj = hashlib.sha256(id_str.encode("utf-8"))
            name = f"app-{hash_obj.hexdigest()[:8]}"

        # Limit length
        name = name[:100]

        return name
    except Exception as e:
        print(f"Name sanitization failed: {e}", file=sys.stderr)
        return f"app-{hashlib.sha256(id_str.encode()).hexdigest()[:8]}"


def find_executable(cmd):
    """Find an executable in PATH with security checks"""
    try:
        # Check if absolute or relative path
        if "/" in cmd:
            if os.path.isfile(cmd) and os.access(cmd, os.X_OK):
                return os.path.abspath(cmd)
            return None

        # Use PATH resolution
        for path_dir in os.getenv("PATH", "").split(":"):
            if not path_dir:
                continue
            exe_path = os.path.join(path_dir, cmd)
            if os.path.isfile(exe_path) and os.access(exe_path, os.X_OK):
                return os.path.abspath(exe_path)

        return None
    except Exception as e:
        print(f"Executable search failed: {e}", file=sys.stderr)
        return None


def safe_mktemp(template="tmp.XXXXXX", dir_param=None):
    """Create a secure temporary file"""
    try:
        # Determine directory
        if dir_param and os.path.isdir(dir_param):
            tdir = dir_param
        else:
            # Use system temp directories
            for temp_dir in [
                os.getenv("TMPDIR"),
                os.getenv("TMP"),
                os.getenv("TEMP"),
                "/tmp",
            ]:
                if temp_dir and os.path.isdir(temp_dir):
                    tdir = temp_dir
                    break
            else:
                tdir = "/tmp"

        # Create secure temp file
        fd, path = tempfile.mkstemp(
            prefix=template.replace("XXXXXX", ""),
            dir=tdir,
            suffix="" if "XXXXXX" not in template else Path(template).suffix,
        )
        os.close(fd)
        return path
    except Exception as e:
        print(f"Temp file creation failed: {e}", file=sys.stderr)
        return None


if __name__ == "__main__":
    # Command line interface for testing
    if len(sys.argv) < 2:
        print("Usage: python3 utils.py <operation> [args...]")
        sys.exit(1)

    operation = sys.argv[1]

    if operation == "canonicalize_path":
        if len(sys.argv) != 3:
            print("Usage: python3 utils.py canonicalize_path <path>")
            sys.exit(1)
        result = canonicalize_path_no_resolve(sys.argv[2])
        print(result or "")
    elif operation == "validate_home":
        if len(sys.argv) != 3:
            print("Usage: python3 utils.py validate_home <dir>")
            sys.exit(1)
        result = validate_home_dir(sys.argv[2])
        print(result or "")
    elif operation == "sanitize_name":
        if len(sys.argv) != 3:
            print("Usage: python3 utils.py sanitize_name <id>")
            sys.exit(1)
        result = sanitize_id_to_name(sys.argv[2])
        print(result or "")
    elif operation == "find_executable":
        if len(sys.argv) != 3:
            print("Usage: python3 utils.py find_executable <cmd>")
            sys.exit(1)
        result = find_executable(sys.argv[2])
        print(result or "")
    elif operation == "is_wrapper_file":
        if len(sys.argv) != 3:
            print("Usage: python3 utils.py is_wrapper_file <file>")
            sys.exit(1)
        result = is_wrapper_file(sys.argv[2])
        print("1" if result else "0")
    elif operation == "get_wrapper_id":
        if len(sys.argv) != 3:
            print("Usage: python3 utils.py get_wrapper_id <file>")
            sys.exit(1)
        result = get_wrapper_id(sys.argv[2])
        print(result or "")
    elif operation == "safe_mktemp":
        if len(sys.argv) < 3:
            print("Usage: python3 utils.py safe_mktemp <template> [dir]")
            sys.exit(1)
        result = safe_mktemp(sys.argv[2], sys.argv[3] if len(sys.argv) > 3 else None)
        print(result or "")
    else:
        print(f"Unknown operation: {operation}")
        sys.exit(1)
