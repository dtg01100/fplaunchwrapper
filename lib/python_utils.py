#!/usr/bin/env python3
"""Robust Python utilities for fplaunchwrapper
This script provides secure implementations of critical operations.
"""
from __future__ import annotations

import contextlib
import hashlib
import os
import re
import sys
import tempfile
import unicodedata
from pathlib import Path

try:
    from platformdirs import user_config_dir, user_data_dir
except ImportError:
    # Fallback implementation
    def user_config_dir(appname):
        return os.path.expanduser(f"~/.config/{appname}")

    def user_data_dir(appname):
        return os.path.expanduser(f"~/.local/share/{appname}")


def sanitize_string(input_str):
    """Safely sanitize a string for use in Python code."""
    if not input_str:
        return ""

    # Escape backslashes and quotes
    sanitized = input_str.replace("\\", "\\\\")
    sanitized = sanitized.replace('"', '\\"')
    sanitized = sanitized.replace("'", "\\'")
    sanitized = sanitized.replace("$", "\\$")
    sanitized = sanitized.replace("`", "\\`")
    sanitized = sanitized.replace("(", "\\(")
    sanitized = sanitized.replace(")", "\\)")
    sanitized = sanitized.replace(";", "\\;")
    sanitized = sanitized.replace("&", "\\&")
    sanitized = sanitized.replace("|", "\\|")
    sanitized = sanitized.replace("<", "\\<")
    sanitized = sanitized.replace(">", "\\>")
    sanitized = sanitized.replace("\n", "\\n")
    sanitized = sanitized.replace("\r", "\\r")
    return sanitized.replace("\t", "\\t")



def canonicalize_path_no_resolve(path):
    """Normalize a path without resolving symlinks."""
    try:
        # Expand tilde
        if path.startswith("~"):
            path = os.path.expanduser(path)

        # Make absolute if relative
        if not os.path.isabs(path):
            path = os.path.abspath(path)

        # Collapse '.' and '..' without resolving symlinks
        return os.path.normpath(path)

    except (TypeError, ValueError, OSError) as e:
        # Handle specific path-related exceptions
        return None


def validate_home_dir(dir_path):
    """Validate that a directory is within HOME."""
    try:
        # Expand tilde
        if dir_path.startswith("~"):
            dir_path = os.path.expanduser(dir_path)

        # Get absolute path
        abs_dir = os.path.abspath(dir_path)

        # Resolve symlinks safely
        if os.path.islink(abs_dir):
            abs_dir = os.path.realpath(abs_dir)

        # Check if within HOME
        home = os.path.expanduser("~")
        if abs_dir == home or abs_dir.startswith(home + os.sep):
            return abs_dir

        return None
    except (TypeError, ValueError, OSError) as e:
        # Handle specific path-related exceptions
        return None


def is_wrapper_file(file_path) -> bool | None:
    """Check if a file is a valid wrapper script."""
    try:
        # Basic validation
        if not os.path.isfile(file_path):
            return False
        if not os.access(file_path, os.R_OK):
            return False
        if os.path.islink(file_path):
            return False

        # Check file size limits
        size = os.path.getsize(file_path)
        if size > 100000:  # 100KB limit
            return False

        # Read file content with proper encoding
        with open(file_path, encoding="utf-8", errors="ignore") as f:
            content = f.read(min(8192, size))

        # Check for binary content
        if any(ord(c) < 32 and c not in "\t\n\r" for c in content):
            return False

        # Check shebang
        if not re.match(r"^#!.*(bash|sh)", content, re.MULTILINE):
            return False

        # Check for marker
        if "Generated by fplaunchwrapper" not in content:
            return False

        # Check for NAME and ID
        name_match = re.search(r"^NAME=[^\n]*", content, re.MULTILINE)
        id_match = re.search(r"^ID=[^\n]*", content, re.MULTILINE)

        if not name_match or not id_match:
            return False

        # Validate ID format
        id_value = re.search(r'ID="([^"]*)"', id_match.group())
        return not (not id_value or not re.match(r"^[A-Za-z0-9._-]+$", id_value.group(1)))
    except (IOError, OSError, UnicodeDecodeError, re.error) as e:
        # Handle specific file and regex exceptions
        return False


def get_wrapper_id(file_path):
    """Extract the wrapper ID from a wrapper script."""
    try:
        # Read file content with proper encoding
        with open(file_path, encoding="utf-8", errors="ignore") as f:
            content = f.read(8192)

        # Try standard ID format first
        id_match = re.search(r'^ID="([^"]*)"', content, re.MULTILINE)
        if id_match:
            return id_match.group(1)

        # Fallback to comment extraction
        comment_match = re.search(r"Flatpak ID:\s*([^\s\n]+)", content)
        if comment_match:
            return comment_match.group(1)

        return None
    except (IOError, OSError, UnicodeDecodeError, re.error) as e:
        # Handle specific file and regex exceptions
        return None


def sanitize_id_to_name(id_str):
    """Sanitize a Flatpak ID to a safe name."""
    try:
        # Extract last component after dots
        name = id_str.split(".")[-1].lower()

        # Unicode normalization and transliteration
        try:
            # Normalize to NFKD and remove diacritics
            name = unicodedata.normalize("NFKD", name)
            name = "".join(c for c in name if not unicodedata.combining(c))
        except ImportError:
            pass

        # Convert to ASCII if possible
        with contextlib.suppress(UnicodeError):
            name = name.encode("ascii", "ignore").decode("ascii")

        # Replace non-alphanumeric characters with hyphens
        name = re.sub(r"[^a-z0-9_\-]", "-", name)

        # Remove leading/trailing hyphens and multiple hyphens
        name = re.sub(r"^\-+|\-+$", "", name)
        name = re.sub(r"\-+", "-", name)

        # Ensure not empty
        if not name:
            # Generate hash-based fallback
            hash_obj = hashlib.sha256(id_str.encode("utf-8"))
            name = f"app-{hash_obj.hexdigest()[:8]}"

        # Limit length
        return name[:100]

    except (TypeError, AttributeError, UnicodeDecodeError, re.error) as e:
        # Handle specific string processing exceptions
        try:
            return f"app-{hashlib.sha256(id_str.encode('utf-8')).hexdigest()[:8]}"
        except Exception:
            return "app-fallback"


def find_executable(cmd):
    """Find an executable in PATH with security checks."""
    try:
        # Check if absolute or relative path
        if "/" in cmd:
            if os.path.isfile(cmd) and os.access(cmd, os.X_OK):
                return os.path.abspath(cmd)
            return None

        # Use PATH resolution
        for path_dir in os.getenv("PATH", "").split(":"):
            if not path_dir:
                continue
            exe_path = os.path.join(path_dir, cmd)
            if os.path.isfile(exe_path) and os.access(exe_path, os.X_OK):
                return os.path.abspath(exe_path)

        return None
    except (TypeError, OSError, AttributeError) as e:
        # Handle specific file system exceptions
        return None


def safe_mktemp(template="tmp.XXXXXX", dir_param=None):
    """Create a secure temporary file."""
    try:
        # Determine directory
        if dir_param and os.path.isdir(dir_param):
            tdir = dir_param
        else:
            # Use system temp directories
            for temp_dir in [
                os.getenv("TMPDIR"),
                os.getenv("TMP"),
                os.getenv("TEMP"),
                "/tmp",
            ]:
                if temp_dir and os.path.isdir(temp_dir):
                    tdir = temp_dir
                    break
            else:
                tdir = "/tmp"

        # Create secure temp file
        fd, path = tempfile.mkstemp(
            prefix=template.replace("XXXXXX", ""),
            dir=tdir,
            suffix="" if "XXXXXX" not in template else Path(template).suffix,
        )
        os.close(fd)
        return path
    except (IOError, OSError, ValueError) as e:
        # Handle specific file system and template exceptions
        return None


def acquire_lock(lock_name="fplaunch", timeout_seconds=30) -> bool | None:
    """Acquire a file-based lock with timeout."""
    try:
        # Get config directory
        from pathlib import Path

        config_dir = Path.home() / ".config" / "fplaunchwrapper"
        config_dir.mkdir(parents=True, exist_ok=True)

        lock_dir = config_dir / "locks"
        lock_dir.mkdir(parents=True, exist_ok=True)

        lockfile = lock_dir / f"{lock_name}.lock"
        pidfile = lock_dir / f"{lock_name}.pid"

        # Try to acquire lock with timeout
        import time

        start_time = time.time()
        end_time = start_time + timeout_seconds

        while time.time() < end_time:
            try:
                # Use mkdir for atomic directory creation as lock
                lockfile.mkdir(parents=True, exist_ok=False)
                # Write PID to lock file
                pidfile.write_text(str(os.getpid()))
                return True
            except FileExistsError:
                # Lock is held by another process
                time.sleep(0.1)
                continue

        return False  # Timeout

    except (IOError, OSError, PermissionError, RuntimeError) as e:
        # Handle specific file system and permission exceptions
        return False


def release_lock(lock_name="fplaunch") -> bool | None:
    """Release a file-based lock."""
    try:
        from pathlib import Path

        config_dir = Path.home() / ".config" / "fplaunchwrapper"
        lock_dir = config_dir / "locks"
        lockfile = lock_dir / f"{lock_name}.lock"
        pidfile = lock_dir / f"{lock_name}.pid"

        # Verify this process owns the lock
        if pidfile.exists():
            stored_pid = pidfile.read_text().strip()
            if stored_pid == str(os.getpid()):
                # Remove lock files
                import shutil

                with contextlib.suppress(FileNotFoundError):
                    shutil.rmtree(lockfile)
                with contextlib.suppress(FileNotFoundError):
                    pidfile.unlink()
                return True

        return False

    except (IOError, OSError, PermissionError) as e:
        # Handle specific file system and permission exceptions
        return False


def get_temp_dir():
    """Get the best available temporary directory."""
    for temp_dir in [
        os.getenv("TMPDIR"),
        os.getenv("TMP"),
        os.getenv("TEMP"),
        os.path.join(os.path.expanduser("~"), ".cache"),
        "/var/tmp",
        "/tmp",
    ]:
        if temp_dir and os.path.isdir(temp_dir) and os.access(temp_dir, os.W_OK):
            return temp_dir

    return "/tmp"


if __name__ == "__main__":
    # Command line interface for testing
    if len(sys.argv) < 2:
        sys.exit(1)

    operation = sys.argv[1]

    if operation == "canonicalize_path":
        if len(sys.argv) != 3:
            sys.exit(1)
        result = canonicalize_path_no_resolve(sys.argv[2])
    elif operation == "validate_home":
        if len(sys.argv) != 3:
            sys.exit(1)
        result = validate_home_dir(sys.argv[2])
    elif operation == "sanitize_name":
        if len(sys.argv) != 3:
            sys.exit(1)
        result = sanitize_id_to_name(sys.argv[2])
    elif operation == "find_executable":
        if len(sys.argv) != 3:
            sys.exit(1)
        result = find_executable(sys.argv[2])
    elif operation == "is_wrapper_file":
        if len(sys.argv) != 3:
            sys.exit(1)
        result = is_wrapper_file(sys.argv[2])
    elif operation == "get_wrapper_id":
        if len(sys.argv) != 3:
            sys.exit(1)
        result = get_wrapper_id(sys.argv[2])
    elif operation == "safe_mktemp":
        if len(sys.argv) < 3:
            sys.exit(1)
        result = safe_mktemp(sys.argv[2], sys.argv[3] if len(sys.argv) > 3 else None)
    else:
        sys.exit(1)
