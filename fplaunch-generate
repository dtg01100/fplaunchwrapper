#!/usr/bin/env bash

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source common utilities
if [ -f "$SCRIPT_DIR/lib/common.sh" ]; then
    # shellcheck source=lib/common.sh disable=SC1091
    source "$SCRIPT_DIR/lib/common.sh"
elif [ -f "${SCRIPT_DIR%/bin}/lib/common.sh" ]; then
    # When installed, lib is relative to bin parent
    # shellcheck source=lib/common.sh disable=SC1091
    source "${SCRIPT_DIR%/bin}/lib/common.sh"
fi

BIN_DIR="${1:-$HOME/bin}"
mkdir -p "$BIN_DIR"

# Save BIN_DIR to config
ensure_config_dir
echo "$BIN_DIR" > "$CONFIG_DIR/bin_dir"

# Get list of installed Flatpak app IDs (user and system)
if ! installed_ids=$( (flatpak list --app --columns=application 2>/dev/null; flatpak list --app --columns=application --system 2>/dev/null) | sort | uniq ); then
    echo "Error: Flatpak not installed or command failed."
    exit 1
fi

# Get list of existing wrapper scripts
shopt -s nullglob
existing_scripts=("$BIN_DIR"/*)
shopt -u nullglob

# Cleanup: Remove wrappers for uninstalled apps
# Identify wrapper files strictly by checking for the marker in the header
for script in "${existing_scripts[@]}"; do
    if is_wrapper_file "$script"; then
        # Extract ID from script content
        id=$(get_wrapper_id "$script")
        # Check if ID is no longer installed using grep on multiline string
        if [ -n "$id" ] && ! grep -q "^$id$" <<< "$installed_ids"; then
            script_name=$(basename "$script")
            rm "$script"
            pref_file="$CONFIG_DIR/$script_name.pref"
            [ -f "$pref_file" ] && rm "$pref_file"
            # Remove aliases pointing to this wrapper
            sed -i "/^$script_name /d" "$CONFIG_DIR/aliases" 2>/dev/null
            for alias in "$BIN_DIR"/*; do
                if [ -L "$alias" ] && [ "$(readlink "$alias" 2>/dev/null)" = "$script" ]; then
                    rm "$alias"
                fi
            done
            echo "Removed obsolete wrapper, preference, and aliases: $script_name"
        fi
    fi
done

# Create wrappers for installed apps
# Use associative array to track wrapper names in this run
declare -A wrapper_names
declare -A wrapper_collision_log

# Use process substitution to avoid subshell (maintains array state)
while read -r id; do
    if [ -z "$id" ]; then continue; fi
    
    # Check blocklist
    if grep -q "^$id$" "$CONFIG_DIR/blocklist" 2>/dev/null; then
        echo "Skipping blocked $id"
        continue
    fi
    
    name=$(echo "$id" | awk -F. '{print tolower($NF)}')
    # Enforce allowed characters and disallow leading/trailing hyphens
    if [ -z "$name" ] || [[ "$name" =~ [^a-z0-9_\-] ]] || [[ "$name" == -* ]] || [[ "$name" == *- ]]; then
        echo "Skipping invalid name for $id"
        continue
    fi
    
    script_path="$BIN_DIR/$name"
    
    # Check for within-run collision (two apps in same installation generating same name)
    if [ -n "${wrapper_names[$name]}" ]; then
        echo "WARNING: Name collision detected for '$name'"
        echo "  First app:  ${wrapper_names[$name]}"
        echo "  Second app: $id"
        echo "  Skipping $id to preserve first wrapper."
        echo "  Consider using aliases: fplaunch-manage set-alias $name ${name}-alt"
        wrapper_collision_log[$name]="${wrapper_collision_log[$name]} $id"
        continue
    fi
    
    # Check for collision with existing wrapper from different app
    if [ -f "$script_path" ] && grep -q "Generated by fplaunchwrapper" "$script_path"; then
        existing_id=$(grep '^ID=' "$script_path" | cut -d'"' -f2)
        if [ "$existing_id" != "$id" ]; then
            echo "WARNING: Name collision with existing wrapper '$name'"
            echo "  Existing: $existing_id"
            echo "  New:      $id"
            echo "  Skipping $id to preserve existing wrapper."
            echo "  To replace, remove the existing wrapper first with: fplaunch-manage remove $name"
            wrapper_collision_log[$name]="${wrapper_collision_log[$name]} $id"
            continue
        fi
    fi
    
    # Track this wrapper name for within-run collision detection
    wrapper_names[$name]=$id
    # shellcheck disable=SC2154
     cat > "$script_path" << EOF
#!/usr/bin/env bash
    # shellcheck disable=SC2154
# Generated by fplaunchwrapper

NAME="$name"
ID="$id"
PREF_DIR="\${XDG_CONFIG_HOME:-\$HOME/.config}/flatpak-wrappers"
PREF_FILE="\$PREF_DIR/\$NAME.pref"
SCRIPT_BIN_DIR="$BIN_DIR"

mkdir -p "\$PREF_DIR"

if [ "\$1" = "--fpwrapper-help" ]; then
    echo "Wrapper for \$NAME"
    echo "Flatpak ID: \$ID"
    pref=\$(cat "\$PREF_FILE" 2>/dev/null || echo "none")
    echo "Current preference: \$pref"
    echo ""
echo "Available options:"
     echo "  --help                          Show basic usage"
     echo "  --fpwrapper-help             Show this detailed help"
     echo "  --fpwrapper-info             Show wrapper info"
     echo "  --fpwrapper-config-dir       Show Flatpak data directory"
     echo "  --fpwrapper-sandbox-info     Show Flatpak sandbox details"
     echo "  --fpwrapper-edit-sandbox     Edit Flatpak permissions"
     echo "  --fpwrapper-sandbox-yolo     Grant all permissions (dangerous)"
     echo "  --fpwrapper-sandbox-reset    Reset sandbox to defaults"
     echo "  --fpwrapper-run-unrestricted Run with unrestricted permissions (transient)"
     echo "  --fpwrapper-set-override [system|flatpak]  Set launch preference"
     echo "  --fpwrapper-set-pre-script <script>        Set pre-launch script"
     echo "  --fpwrapper-set-post-script <script>       Set post-run script"
     echo "  --fpwrapper-remove-pre-script               Remove pre-launch script"
     echo "  --fpwrapper-remove-post-script              Remove post-run script"
    echo ""
echo "Examples:"
     echo "  \$NAME --fpwrapper-info"
     echo "  cd \"\\\$(\\\$NAME --fpwrapper-config-dir)\""
     echo "  \$NAME --fpwrapper-sandbox-info"
     echo "  \$NAME --fpwrapper-edit-sandbox"
     echo "  \$NAME --fpwrapper-sandbox-yolo"
     echo "  \$NAME --fpwrapper-sandbox-reset"
     echo "  \$NAME --fpwrapper-run-unrestricted"
     echo "  \$NAME --fpwrapper-set-override system"
     echo "  \$NAME --fpwrapper-set-pre-script ~/scripts/my-pre-script.sh"
     echo "  \$NAME --fpwrapper-set-post-script ~/scripts/my-post-script.sh"
     echo "  \$NAME --fpwrapper-remove-pre-script"
     echo "  \$NAME --fpwrapper-remove-post-script"
    exit 0
elif [ "\$1" = "--fpwrapper-info" ]; then
    echo "Wrapper for \$NAME"
    echo "Flatpak ID: \$ID"
    pref=\$(cat "\$PREF_FILE" 2>/dev/null || echo "none")
    echo "Preference: \$pref"
    echo "Usage: \$0 [args]"
    exit 0
elif [ "\$1" = "--fpwrapper-config-dir" ]; then
    # Use XDG Base Directory specification for config directory
    config_dir="${XDG_DATA_HOME:-$HOME/.local}/share/applications/$ID"
    echo "\$config_dir"
    exit 0
elif [ "\$1" = "--fpwrapper-sandbox-info" ]; then
    flatpak info "\$ID"
    exit 0
elif [ "\$1" = "--fpwrapper-edit-sandbox" ]; then
    echo "Flatpak Sandbox Editor for \$ID"
    echo "Common permissions:"
    echo "1. Allow filesystem access (e.g., ~/Documents)"
    echo "2. Allow device access (e.g., --device=dri)"
    echo "3. Allow network access"
    echo "4. Reset all overrides"
    echo "5. Show current overrides"
    echo "6. YOLO mode (open all permissions)"
    read -p "Choose an option (1-6): " opt
    case \$opt in
        1)
            read -p "Enter path (e.g., ~/Documents): " path
            flatpak override "\$ID" --filesystem="\$path"
            ;;
        2)
            read -p "Enter device (e.g., dri): " dev
            flatpak override "\$ID" --device="\$dev"
            ;;
        3)
            flatpak override "\$ID" --share=network
            ;;
        4)
            flatpak override --reset "\$ID"
            ;;
        5)
            flatpak override "\$ID"
            ;;
        6)
            echo "WARNING: YOLO mode grants extensive permissions and may pose security risks!"
            read -p "Are you sure? (yes/no): " confirm
            if [ "\$confirm" = "yes" ]; then
                flatpak override "\$ID" --filesystem=host --share=network --device=all --allow=devel
                echo "YOLO mode applied. Use 'flatpak override --reset \$ID' to reset."
            else
                echo "Cancelled."
            fi
            ;;
        *)
            echo "Invalid option"
            ;;
    esac
    exit 0
elif [ "\$1" = "--fpwrapper-sandbox-yolo" ]; then
    echo "WARNING: YOLO mode grants extensive permissions and may pose security risks!"
    read -p "Are you sure? (yes/no): " confirm
    if [ "\$confirm" = "yes" ]; then
        flatpak override "\$ID" --filesystem=host --share=network --device=all --allow=devel
        echo "YOLO mode applied. Use 'flatpak override --reset \$ID' to reset."
    else
        echo "Cancelled."
    fi
    exit 0
elif [ "\$1" = "--fpwrapper-set-override" ]; then
    if [ -z "\$2" ]; then
        echo "Choose override:"
        echo "1. system"
        echo "2. flatpak"
        read -r -p "Choice (1/2): " choice
        if [ "\$choice" = "1" ]; then
            pref="system"
        elif [ "\$choice" = "2" ]; then
            pref="flatpak"
        else
            echo "Invalid choice"
            exit 1
        fi
    else
        pref="\$2"
    fi
    if [ "\$pref" = "system" ] || [ "\$pref" = "flatpak" ]; then
        echo "\$pref" > "\$PREF_FILE"
        echo "Preference set to \$pref"
    else
        echo "Invalid override: use 'system' or 'flatpak'"
    fi
    exit 0
elif [ "\$1" = "--fpwrapper-set-pre-script" ]; then
    if [ -z "\$2" ]; then
        echo "Usage: \$0 --fpwrapper-set-pre-script <script_path>"
        echo "Set a pre-launch script to run before the Flatpak app starts."
        exit 1
    fi
    if [ ! -f "\$2" ]; then
        echo "Script file not found: \$2"
        exit 1
    fi
    script_dir="\$PREF_DIR/scripts/\$NAME"
    mkdir -p "\$script_dir"
    cp "\$2" "\$script_dir/pre-launch.sh"
    chmod +x "\$script_dir/pre-launch.sh"
    echo "Pre-launch script set for \$NAME"
    exit 0
elif [ "\$1" = "--fpwrapper-set-post-script" ]; then
    if [ -z "\$2" ]; then
        echo "Usage: \$0 --fpwrapper-set-post-script <script_path>"
        echo "Set a post-run script to run after the Flatpak app exits."
        exit 1
    fi
    if [ ! -f "\$2" ]; then
        echo "Script file not found: \$2"
        exit 1
    fi
    script_dir="\$PREF_DIR/scripts/\$NAME"
    mkdir -p "\$script_dir"
    cp "\$2" "\$script_dir/post-run.sh"
    chmod +x "\$script_dir/post-run.sh"
    echo "Post-run script set for \$NAME"
    exit 0
elif [ "\$1" = "--fpwrapper-remove-pre-script" ]; then
    rm -f "\$PREF_DIR/scripts/\$NAME/pre-launch.sh"
    echo "Pre-launch script removed for \$NAME"
    exit 0
elif [ "\$1" = "--fpwrapper-remove-post-script" ]; then
    rm -f "\$PREF_DIR/scripts/\$NAME/post-run.sh"
    echo "Post-run script removed for \$NAME"
    exit 0
fi

# Function to execute pre-launch script
run_pre_launch_script() {
    PRE_LAUNCH_SCRIPT="\$PREF_DIR/scripts/\$NAME/pre-launch.sh"
    if [ -f "\$PRE_LAUNCH_SCRIPT" ] && [ -x "\$PRE_LAUNCH_SCRIPT" ]; then
        echo "Running pre-launch script for \$NAME..."
        "\$PRE_LAUNCH_SCRIPT" "\$NAME" "\$ID" "\$@" || {
            echo "Pre-launch script failed. Continue anyway? (y/n) [y]: "
            read -r confirm
            confirm=\${confirm:-y}
            if [[ ! \$confirm =~ ^[Yy]\$ ]]; then
                echo "Aborted by user."
                exit 1
            fi
        }
    fi
}

# Function to execute post-run script
run_post_run_script() {
    local exit_code=\$1
    POST_RUN_SCRIPT="\$PREF_DIR/scripts/\$NAME/post-run.sh"
    if [ -f "\$POST_RUN_SCRIPT" ] && [ -x "\$POST_RUN_SCRIPT" ]; then
        echo "Running post-run script for \$NAME..."
        "\$POST_RUN_SCRIPT" "\$NAME" "\$ID" "\$exit_code" || true
    fi
}

# Function to load environment variables
load_env_vars() {
    ENV_FILE="\$PREF_DIR/\$NAME.env"
    if [ -f "\$ENV_FILE" ]; then
        # Source the env file to load variables
        source "\$ENV_FILE"
    fi
}

# Function to run command and handle post-run scripts
run_and_cleanup() {
    # Run the command and capture exit code
    "\$@"
    local exit_code=\$?
    
    # Run post-run script if it exists
    run_post_run_script "\$exit_code"
    
    # Exit with same code as the command
    exit \$exit_code
}

if [ -f "\$PREF_FILE" ]; then
    PREF=\$(cat "\$PREF_FILE")
else
    PREF=""
fi

# Check for system command at launch time (SECURITY-HARDED PATH RESOLUTION)
SYSTEM_EXISTS=false
CMD_PATH=""

# Security-hardened PATH parsing with input validation
# Sanitize PATH to prevent injection attacks
SAFE_PATH="\${PATH:-/usr/local/bin:/usr/bin:/bin}"

# Remove dangerous characters and normalize
# This prevents PATH injection attacks
SAFE_PATH=\$(echo "\$SAFE_PATH" | sed 's/[^a-zA-Z0-9\/\:\.\-\_]/:/g')

# Parse PATH defensively
IFS=':' read -ra PATH_DIRS <<< "\$SAFE_PATH"
for sys_dir in "\${PATH_DIRS[@]}"; do
    # Skip empty or dangerous directory entries
    [ -z "\$sys_dir" ] && continue
    
    # Skip current directory (.) to prevent local script execution
    [ "\$sys_dir" = "." ] && continue
    
    # Skip parent directory references to prevent directory traversal
    case "\$sys_dir" in
        *\.\.*|*\/\.\.\/|*\/\.\.$|\.\.\/\*|\/\.\.\/\*)
            echo "SECURITY: Skipping dangerous path: \$sys_dir" >&2
            continue
            ;;
    esac
    
# Skip absolute paths that look like user directories
    case "$sys_dir" in
        "$HOME"/*|\~/*|/tmp/*|/var/*|/home/*/.*|/root/.*/)
            echo "SECURITY: Skipping user/private directory: $sys_dir" >&2
            continue
            ;;
        /home/*/.local/bin/*|/opt/*/bin/*|/snap/*)
            echo "SECURITY: Skipping user-controlled system directory: $sys_dir" >&2
            continue
            ;;
    esac
    
    # Skip paths with null bytes or encoding attacks
    if [[ "$sys_dir" =~ \\x00|\\u0000|%C0%2e|%2e%2e ]]; then
        echo "SECURITY: Skipping encoded/suspicious path: $sys_dir" >&2
        continue
    fi
    
    # Skip paths with command injection patterns
    if [[ "$sys_dir" =~ :[xX][0-9a-zA-Z_-]+: ]]; then
        echo "SECURITY: Skipping potential command injection: $sys_dir" >&2
        continue
    fi
    
    # Skip paths with suspicious characters
    if [[ ! "\$sys_dir" =~ ^/([a-zA-Z0-9\.\_\-]+/)*[a-zA-Z0-9\.\_\-]+$ ]]; then
        echo "SECURITY: Skipping malformed path: \$sys_dir" >&2
        continue
    fi
    
    # Skip excessively long paths (potential buffer overflow protection)
    if [ \${#sys_dir} -gt 256 ]; then
        echo "SECURITY: Skipping overly long path" >&2
        continue
    fi
    
    # Skip if directory doesn't exist (prevents false positives)
    if [ ! -d "\$sys_dir" ]; then
        continue
    fi
    
    # Skip if directory is not readable (security check)
    if [ ! -r "\$sys_dir" ]; then
        echo "SECURITY: Skipping unreadable directory: \$sys_dir" >&2
        continue
    fi
    
    candidate="\$sys_dir/\$NAME"
    
    # Additional validation of candidate path
    # Skip if candidate path is suspicious
    if [[ "$candidate" =~ [\;\|\&\$\`\<\>] ]]; then
        echo "SECURITY: Skipping candidate with dangerous characters: $candidate" >&2
        continue
    fi
    
    # Additional validation: ensure candidate is a regular file (not symlink)
    if [ -L "$candidate" ]; then
        echo "SECURITY: Skipping symlink candidate: $candidate" >&2
        continue
    fi
    
    # Skip if candidate path is excessively long
    if [ \${#candidate} -gt 512 ]; then
        echo "SECURITY: Skipping overly long candidate path" >&2
        continue
    fi
    
    # Check if this is our own wrapper script - if so, skip it
    if [ "\$candidate" = "\$SCRIPT_BIN_DIR/\$NAME" ]; then
        echo "SECURITY: Skipping our own wrapper at \$candidate" >&2
        continue
    fi
    
    # Final security checks before testing file
    # Ensure candidate is within expected system directories
    case "\$sys_dir" in
        /usr/local/bin|/usr/bin|/bin|/usr/local/sbin|/usr/sbin|/sbin|/opt/*/bin|/opt/bin)
            # Allow standard system directories
            ;;
        *)
            echo "SECURITY: Skipping non-system directory: \$sys_dir" >&2
            continue
            ;;
    esac
    
    # Check if executable exists in this PATH directory
    if [ -f "\$candidate" ] && [ -x "\$candidate" ]; then
        # Additional verification: ensure file is not a symlink to wrapper location
        if [ -L "\$candidate" ]; then
            link_target=\$(readlink -f "\$candidate" 2>/dev/null)
            if [ "\$link_target" = "\$SCRIPT_BIN_DIR/\$NAME" ]; then
                echo "SECURITY: Skipping symlink to wrapper: \$candidate" >&2
                continue
            fi
        fi
        
        # Verify file is owned by root or system user (additional security)
        # Use more robust system binary detection
        local file_uid
        file_uid=$(stat -c %u "$candidate" 2>/dev/null)
        local is_system_binary=false
        
        # Check for common system UIDs (root, bin, daemon, etc.)
        case "$file_uid" in
            0|1|2|3|4|6|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55|56|57|58|59|60|61|62|63|64|65|66|67|68|69|70|71|72|73|74|75|76|77|78|79|80|81|82|83|84|85|86|87|88|89|90|91|92|93|94|95|96|97|98|99|65534|65535)
                is_system_binary=true
                ;;
        esac
        
        if [ "$is_system_binary" = false ]; then
            echo "SECURITY: Skipping non-system owned file: $candidate (UID: $file_uid)" >&2
            continue
        fi
        
        SYSTEM_EXISTS=true
        CMD_PATH="\$candidate"
        echo "SECURITY: Found system binary at \$candidate" >&2
        break
    fi
done

# Fallback to hardcoded paths if PATH parsing fails (safety net)
if [ "\$SYSTEM_EXISTS" = false ]; then
    echo "SECURITY: PATH parsing found nothing, checking fallback paths" >&2
    for sys_dir in "/usr/local/bin" "/usr/bin" "/bin" "/usr/local/sbin" "/usr/sbin" "/sbin"; do
        candidate="\$sys_dir/\$NAME"
        if [ -f "\$candidate" ] && [ -x "\$candidate" ] && [ "\$candidate" != "\$SCRIPT_BIN_DIR/\$NAME" ]; then
            SYSTEM_EXISTS=true
            CMD_PATH="\$candidate"
            echo "DEBUG: Found system binary in fallback path: \$candidate" >&2
            break
        fi
    done
fi

if [ "\$PREF" = "system" ]; then
    if [ "\$SYSTEM_EXISTS" = true ]; then
        load_env_vars
        run_pre_launch_script "\$@"
        run_and_cleanup "\$NAME" "\$@"
    else
        # System command gone, fall back to flatpak
        # Atomic preference update to prevent race conditions
        local temp_pref_file
        temp_pref_file=$(mktemp "$PREF_FILE.tmp.XXXXXX")
        echo "flatpak" > "$temp_pref_file"
        mv "$temp_pref_file" "$PREF_FILE"
        
        load_env_vars
        run_pre_launch_script "$@"
        run_and_cleanup flatpak run "$ID" "$@"
    fi
elif [ "\$PREF" = "flatpak" ]; then
    load_env_vars
    run_pre_launch_script "\$@"
    run_and_cleanup flatpak run "\$ID" "\$@"
    else
        # No pref set
        if [ "$SYSTEM_EXISTS" = true ]; then
            # Sensible default: prefer system package when available
            local default_choice="system"
            local choice_reason="system package available"
            
            echo "Multiple options for '$NAME':"
            echo "1. System package ($CMD_PATH)"
            echo "2. Flatpak app ($ID)"
            echo ""
            read -r -p "Choose (1/2, default 1 - $choice_reason): " choice
            choice=${choice:-1}
            
            if [ "$choice" = "1" ]; then
                PREF="system"
            elif [ "$choice" = "2" ]; then
                PREF="flatpak"
            else
                echo "Invalid choice '$choice', using default: $default_choice"
                PREF="$default_choice"
            fi
            
            # Atomic preference update
            local temp_pref_file
            temp_pref_file=$(mktemp "$PREF_FILE.tmp.XXXXXX")
            echo "$PREF" > "$temp_pref_file"
            mv "$temp_pref_file" "$PREF_FILE"
            
            load_env_vars
            run_pre_launch_script "$@"
            
            if [ "$PREF" = "system" ]; then
                run_and_cleanup "$NAME" "$@"
            else
                run_and_cleanup flatpak run "$ID" "$@"
            fi
        else
            # Only flatpak available
            PREF="flatpak"
            echo "$PREF" > "$PREF_FILE"
            load_env_vars
            run_pre_launch_script "$@"
            run_and_cleanup flatpak run "$ID" "$@"
        fi
    else
        PREF="flatpak"
        echo "\$PREF" > "\$PREF_FILE"
        load_env_vars
        run_pre_launch_script "\$@"
        run_and_cleanup flatpak run "\$ID" "\$@"
    fi
fi
EOF
    chmod +x "$script_path"
    echo "Created/updated wrapper: $name"
done < <(echo "$installed_ids")

# Report collision summary if any occurred
if [ ${#wrapper_collision_log[@]} -gt 0 ]; then
    echo ""
    echo "=== Collision Summary ==="
    echo "${#wrapper_collision_log[@]} wrapper name(s) had collisions:"
    for name in "${!wrapper_collision_log[@]}"; do
        echo "  $name: Skipped apps:${wrapper_collision_log[$name]}"
    done
    echo "Use 'fplaunch-manage set-alias' to create alternative names for skipped apps."
fi

echo "Flatpak wrapper generation complete."