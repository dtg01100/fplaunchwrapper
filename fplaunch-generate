#!/usr/bin/env bash

# Safety check - never run as root
if [ "$(id -u)" = "0" ]; then
    echo "ERROR: fplaunch-generate should never be run as root for safety"
    echo "This tool is designed for user-level wrapper management only"
    exit 1
fi

# Validate HOME directory
if [ -z "${HOME:-}" ] || [ ! -d "$HOME" ]; then
    echo "Error: HOME directory is not set or not accessible: ${HOME:-<not set>}"
    echo ""
    echo "Alternative: You can set a custom HOME directory by setting:"
    echo "  export HOME=/path/to/your/home"
    exit 1
fi

# Validate PATH
if [ -z "${PATH:-}" ]; then
    echo "Warning: PATH is not set, some functionality may not work"
    echo ""
    echo "Alternative: You can set a custom PATH by setting:"
    echo "  export PATH=/path/to/your/bin:/usr/bin:/bin"
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source common utilities
if [ -f "$SCRIPT_DIR/lib/common.sh" ]; then
    # shellcheck source=lib/common.sh disable=SC1091
    source "$SCRIPT_DIR/lib/common.sh"
elif [ -f "${SCRIPT_DIR%/bin}/lib/common.sh" ]; then
    # When installed, lib is relative to bin parent
    # shellcheck source=lib/common.sh disable=SC1091
    source "${SCRIPT_DIR%/bin}/lib/common.sh"
fi

# Validate BIN_DIR
if [ -z "${1:-}" ]; then
    echo "Error: No BIN_DIR specified"
    echo "Usage: $0 [BIN_DIR]"
    exit 1
fi

BIN_DIR="${1:-$HOME/bin}"

# Validate BIN_DIR sits under HOME
if ! validate_home_dir "$(dirname "$BIN_DIR")" >/dev/null 2>&1; then
    echo "Error: BIN_DIR must be under your HOME directory: $BIN_DIR" >&2
    echo "Please choose a location under your home directory or set BIN_DIR accordingly." >&2
    echo "Alternative: You can specify a different bin directory:"
    echo "  $0 /path/to/your/bin"
    echo "  export BIN_DIR=/path/to/your/bin"
    exit 1
fi

# Try to create BIN_DIR with error handling
if ! mkdir -p "$BIN_DIR" 2>/dev/null; then
    echo "Error: Cannot create BIN_DIR: $BIN_DIR" >&2
    echo "Please check permissions and disk space." >&2
    echo ""
    echo "Alternative: You can specify a different bin directory:"
    echo "  $0 /path/to/your/bin"
    echo "  export BIN_DIR=/path/to/your/bin"
    exit 1
fi

# Save BIN_DIR to config
if ! ensure_config_dir; then
    echo "Error: Failed to create config directory" >&2
    exit 1
fi

# Ensure enough disk space
if ! check_disk_space "$BIN_DIR" 10; then
    echo "Error: Not enough disk space available in $BIN_DIR" >&2
    echo "Please free space or choose a different BIN_DIR." >&2
    exit 1
fi

echo "$BIN_DIR" > "$CONFIG_DIR/bin_dir"

# Acquire global lock for this operation to prevent race conditions
if ! acquire_lock; then
    echo "Error: Failed to acquire lock for generation" >&2
    exit 1
fi
trap 'release_lock' EXIT

# Get list of installed Flatpak app IDs (user and system)
if ! FLATPAK_BIN=$(find_executable flatpak 2>/dev/null); then
    echo "‚ùå Flatpak not found"
    echo ""
    echo "üì¶ Install Flatpak first:"
    echo "  Ubuntu/Debian: sudo apt install flatpak && sudo apt install flatpak-plugin-gnome"
    echo "  Fedora:         sudo dnf install flatpak"
    echo "  Arch:           sudo pacman -S flatpak"
    echo "  openSUSE:       sudo zypper install flatpak"
    echo ""
    echo "üåê Or visit: https://flatpak.org/setup/"
    echo ""
    echo "üí° After installation, run: flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo"
    exit 1
fi

if ! installed_ids=$( ("$FLATPAK_BIN" list --app --columns=application 2>/dev/null; "$FLATPAK_BIN" list --app --columns=application --system 2>/dev/null) | sort | uniq ); then
    echo "‚ùå Flatpak command failed"
    echo ""
    echo "üîß Troubleshooting steps:"
    echo "  1. Check Flatpak version: $FLATPAK_BIN --version"
    echo "  2. List apps manually: $FLATPAK_BIN list --app"
    echo "  3. Check if Flatpak service is running:"
    echo "     systemctl --user status flatpak-session-helper"
    echo "  4. Restart Flatpak service:"
    echo "     systemctl --user restart flatpak-session-helper"
    echo ""
    echo "üí° If you just installed Flatpak, you may need to:"
    echo "   - Add Flathub remote: flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo"
    echo "   - Install some apps: flatpak install flathub org.mozilla.firefox"
    exit 1
fi

# Count installed apps
app_count=$(echo "$installed_ids" | grep -c .)
echo "üîç Found $app_count Flatpak applications"

# Get list of existing wrapper scripts
shopt -s nullglob
existing_scripts=("$BIN_DIR"/*)
shopt -u nullglob

# Cleanup: Remove wrappers for uninstalled apps
echo "üßπ Cleaning up obsolete wrappers..."
removed_count=0
for script in "${existing_scripts[@]}"; do
    if is_wrapper_file "$script"; then
        # Extract ID from script content
        id=$(get_wrapper_id "$script")
        # Check if ID is no longer installed using grep on multiline string
        if [ -n "$id" ] && ! grep -q "^$id$" <<< "$installed_ids"; then
            script_name=$(basename "$script")
            # Remove wrapper with error handling
            if ! rm "$script" 2>/dev/null; then
                echo "Warning: Could not remove wrapper: $script"
            else
                echo "   üóëÔ∏è  Removed obsolete wrapper: $script_name"
                removed_count=$((removed_count + 1))
            fi
            # Remove preference file with error handling
            pref_file="$CONFIG_DIR/$script_name.pref"
            if [ -f "$pref_file" ]; then
                if ! rm "$pref_file" 2>/dev/null; then
                    echo "Warning: Could not remove preference file: $pref_file"
                fi
            fi
            # Remove aliases pointing to this wrapper
            if [ -f "$CONFIG_DIR/aliases" ]; then
                if ! sed -i "/^$script_name /d" "$CONFIG_DIR/aliases" 2>/dev/null; then
                    echo "Warning: Could not remove alias for: $script_name"
                fi
            fi
            # Remove symbolic links pointing to this wrapper
            for alias in "$BIN_DIR"/*; do
                if [ -L "$alias" ] && [ "$(readlink "$alias" 2>/dev/null)" = "$script" ]; then
                    if ! rm "$alias" 2>/dev/null; then
                        echo "Warning: Could not remove symlink: $alias"
                    fi
                fi
            done
        fi
    fi
done

if [ $removed_count -eq 0 ]; then
    echo "   ‚úÖ No obsolete wrappers found"
else
    echo "   üóëÔ∏è  Removed $removed_count obsolete wrapper(s)"
fi

# Create wrappers for installed apps
echo "üì¶ Generating wrappers..."
created_count=0
updated_count=0
skipped_count=0
blocked_count=0

# Simple collision detection using temp file with error handling
if ! COLLISION_FILE=$(safe_mktemp "collision.XXXXXX" "$(get_temp_dir 2>/dev/null || echo /tmp)"); then
    echo "‚ùå Cannot create temporary file for collision detection"
    echo "Please check file permissions and disk space"
    echo ""
    echo "Alternative: You can set a custom temp directory by setting:"
    echo "  export TMPDIR=/path/to/your/temp"
    echo "  export TMP=/path/to/your/temp"
    echo "  export TEMP=/path/to/your/temp"
    exit 1
fi

while read -r id; do
    if [ -z "$id" ]; then continue; fi
    
    # Check blocklist
    if grep -q "^$id$" "$CONFIG_DIR/blocklist" 2>/dev/null; then
        echo "   üö´ Skipping blocked $id"
        blocked_count=$((blocked_count + 1))
        continue
    fi
    
    name=$(sanitize_id_to_name "$id")
    # Enforce allowed characters and disallow leading/trailing hyphens
    if [ -z "$name" ] || [[ "$name" =~ [^a-z0-9_\-] ]] || [[ "$name" == -* ]] || [[ "$name" == *- ]]; then
        echo "   ‚ö†Ô∏è  Skipping invalid name for $id: $name"
        skipped_count=$((skipped_count + 1))
        continue
    fi
    
    script_path="$BIN_DIR/$name"
    
    # Simple collision detection
    if grep -q "^$name:" "$COLLISION_FILE"; then
        echo "   ‚ö†Ô∏è  Name collision for '$name' - skipping $id"
        skipped_count=$((skipped_count + 1))
        continue
    fi
    echo "$name:$id" >> "$COLLISION_FILE"
    
    # Check for collision with existing wrapper from different app
    wrapper_existed=false
    if [ -f "$script_path" ] && grep -q "Generated by fplaunchwrapper" "$script_path"; then
        wrapper_existed=true
        existing_id=$(grep '^ID=' "$script_path" | cut -d'"' -f2)
        if [ "$existing_id" != "$id" ]; then
            echo "   ‚ö†Ô∏è  Name collision with existing wrapper '$name'"
            echo "      Existing: $existing_id"
            echo "      New:      $id"
            echo "      üí° To replace: fplaunch-manage remove $name"
            wrapper_collision_log[$name]="${wrapper_collision_log[$name]} $id"
            skipped_count=$((skipped_count + 1))
            continue
        fi
    fi
    
    # Track this wrapper name for within-run collision detection
    
    # shellcheck disable=SC2154
    cat > "$script_path" << EOF
#!/usr/bin/env bash
    # shellcheck disable=SC2154
# Generated by fplaunchwrapper

NAME="$name"
ID="$id"
PREF_DIR="\${XDG_CONFIG_HOME:-\$HOME/.config}/flatpak-wrappers"
PREF_FILE="\$PREF_DIR/\$NAME.pref"
SCRIPT_BIN_DIR="$BIN_DIR"
ONE_SHOT_PREF=""

mkdir -p "\$PREF_DIR"

# Check if running in interactive CLI
is_interactive() {
    [ -t 0 ] && [ -t 1 ] && [ "${FPWRAPPER_FORCE:-}" != "desktop" ]
}

# Discover system binary (if present) and avoid pointing to our own wrapper
set_system_info() {
    SYSTEM_EXISTS=false
    CMD_PATH=""
    if command -v "\$NAME" >/dev/null 2>&1; then
        CMD_PATH=$(command -v "\$NAME")
        if [ "\$CMD_PATH" != "\$SCRIPT_BIN_DIR/\$NAME" ]; then
            SYSTEM_EXISTS=true
        else
            CMD_PATH=""
        fi
    fi
}

# Run a single launch choice without persisting preferences
run_single_launch() {
    local choice="\$1"
    shift

    load_env_vars
    run_pre_launch_script "\$@"

    if [ "\$choice" = "system" ]; then
        if [ "\$SYSTEM_EXISTS" = true ]; then
            run_and_cleanup "\$NAME" "\$@"
        else
            echo "System binary not found; falling back to flatpak for this launch." >&2
            run_and_cleanup flatpak run "\$ID" "\$@"
        fi
    else
        run_and_cleanup flatpak run "\$ID" "\$@"
    fi
}

# Check for force flag for testing
if [ "\$1" = "--fpwrapper-force-interactive" ]; then
    export FPWRAPPER_FORCE=interactive
    shift
fi

# One-shot launch selector (non-persistent)
if [ "\$1" = "--fpwrapper-launch" ]; then
    if [ -z "\$2" ]; then
        echo "Usage: \$NAME --fpwrapper-launch [system|flatpak]" >&2
        exit 1
    fi
    case "\$2" in
        system|flatpak)
            ONE_SHOT_PREF="\$2"
            shift 2
            ;;
        *)
            echo "Invalid choice for --fpwrapper-launch: \$2 (use system|flatpak)" >&2
            exit 1
            ;;
    esac
fi

# Discover system info once for this invocation
set_system_info

# Non-interactive bypass: skip wrapper and continue PATH search (unless one-shot specified)
if ! is_interactive; then
    if [ -n "\$ONE_SHOT_PREF" ]; then
        run_single_launch "\$ONE_SHOT_PREF" "\$@"
    fi

    # Find next executable in PATH (skip our wrapper)
    IFS=: read -ra PATH_DIRS <<< "\$PATH"
    for dir in "${PATH_DIRS[@]}"; do
        [ -z "$dir" ] && continue
        if [ -x "$dir/$NAME" ] && [ "$dir/$NAME" != "$SCRIPT_BIN_DIR/$NAME" ]; then
            exec "$dir/$NAME" "\$@"
        fi
    done
    
    # If no system command found, run flatpak
    exec flatpak run "\$ID" "\$@"
fi

if [ "\$1" = "--fpwrapper-help" ]; then
    echo "Wrapper for \$NAME"
    echo "Flatpak ID: \$ID"
    pref=\$(cat "\$PREF_FILE" 2>/dev/null || echo "none")
    echo "Current preference: \$pref"
    echo ""
echo "Available options:"
     echo "  --help                          Show basic usage"
     echo "  --fpwrapper-help             Show this detailed help"
     echo "  --fpwrapper-info             Show wrapper info"
     echo "  --fpwrapper-config-dir       Show Flatpak data directory"
     echo "  --fpwrapper-sandbox-info     Show Flatpak sandbox details"
     echo "  --fpwrapper-edit-sandbox     Edit Flatpak permissions"
     echo "  --fpwrapper-sandbox-yolo     Grant all permissions (dangerous)"
     echo "  --fpwrapper-sandbox-reset    Reset sandbox to defaults"
     echo "  --fpwrapper-run-unrestricted Run with unrestricted permissions (transient)"
     echo "  --fpwrapper-force-interactive    Force interactive mode for testing"
    echo "  --fpwrapper-set-override [system|flatpak]  Set launch preference"
    echo "  --fpwrapper-launch [system|flatpak]        Launch once without saving preference"
     echo "  --fpwrapper-set-pre-script <script>        Set pre-launch script"
     echo "  --fpwrapper-set-post-script <script>       Set post-run script"
     echo "  --fpwrapper-remove-pre-script               Remove pre-launch script"
     echo "  --fpwrapper-remove-post-script              Remove post-run script"
    echo ""
echo "Examples:"
     echo "  \$NAME --fpwrapper-info"
     echo "  cd \"\\\$(\\\$NAME --fpwrapper-config-dir)\""
     echo "  \$NAME --fpwrapper-sandbox-info"
     echo "  \$NAME --fpwrapper-edit-sandbox"
     echo "  \$NAME --fpwrapper-sandbox-yolo"
     echo "  \$NAME --fpwrapper-sandbox-reset"
     echo "  \$NAME --fpwrapper-run-unrestricted"
     echo "  \$NAME --fpwrapper-force-interactive"
     echo "  \$NAME --fpwrapper-set-override system"
    echo "  $NAME --fpwrapper-launch flatpak -- --version"
     echo "  \$NAME --fpwrapper-set-pre-script ~/scripts/my-pre-script.sh"
     echo "  \$NAME --fpwrapper-set-post-script ~/scripts/my-post-script.sh"
     echo "  \$NAME --fpwrapper-remove-pre-script"
     echo "  \$NAME --fpwrapper-remove-post-script"
    exit 0
elif [ "\$1" = "--fpwrapper-info" ]; then
    echo "Wrapper for \$NAME"
    echo "Flatpak ID: \$ID"
    pref=\$(cat "\$PREF_FILE" 2>/dev/null || echo "none")
    echo "Preference: \$pref"
    echo "Usage: \$0 [args]"
    exit 0
elif [ "\$1" = "--fpwrapper-config-dir" ]; then
    # Use XDG Base Directory specification for config directory
    config_dir="${XDG_DATA_HOME:-$HOME/.local/share}/applications/$ID"
    echo "\$config_dir"
    exit 0
elif [ "\$1" = "--fpwrapper-sandbox-info" ]; then
    flatpak info "\$ID"
    exit 0
elif [ "\$1" = "--fpwrapper-edit-sandbox" ]; then
    if ! is_interactive; then
        echo "Error: Sandbox editing requires interactive CLI" >&2
        exit 1
    fi
    echo "Flatpak Sandbox Editor for \$ID"
    echo "Common permissions:"
    echo "1. Allow filesystem access (e.g., ~/Documents)"
    echo "2. Allow device access (e.g., --device=dri)"
    echo "3. Allow network access"
    echo "4. Reset all overrides"
    echo "5. Show current overrides"
    echo "6. YOLO mode (open all permissions)"
    read -p "Choose an option (1-6): " opt
    case \$opt in
        1)
            read -p "Enter path (e.g., ~/Documents): " path
            flatpak override "\$ID" --filesystem="\$path"
            ;;
        2)
            read -p "Enter device (e.g., dri): " dev
            flatpak override "\$ID" --device="\$dev"
            ;;
        3)
            flatpak override "\$ID" --share=network
            ;;
        4)
            flatpak override --reset "\$ID"
            ;;
        5)
            flatpak override "\$ID"
            ;;
        6)
            echo "WARNING: YOLO mode grants extensive permissions and may pose security risks!"
            read -p "Are you sure? (yes/no): " confirm
            if [ "\$confirm" = "yes" ]; then
                flatpak override "\$ID" --filesystem=host --share=network --device=all --allow=devel
                echo "YOLO mode applied. Use 'flatpak override --reset \$ID' to reset."
            else
                echo "Cancelled."
            fi
            ;;
        *)
            echo "Invalid option"
            ;;
    esac
    exit 0
elif [ "\$1" = "--fpwrapper-sandbox-yolo" ]; then
    echo "WARNING: YOLO mode grants extensive permissions and may pose security risks!"
    read -p "Are you sure? (yes/no): " confirm
    if [ "\$confirm" = "yes" ]; then
        flatpak override "\$ID" --filesystem=host --share=network --device=all --allow=devel
        echo "YOLO mode applied. Use 'flatpak override --reset \$ID' to reset."
    else
        echo "Cancelled."
    fi
    exit 0
elif [ "\$1" = "--fpwrapper-set-override" ]; then
    if [ -z "\$2" ]; then
        echo "Choose override:"
        echo "1. system"
        echo "2. flatpak"
        read -r -p "Choice (1/2): " choice
        if [ "\$choice" = "1" ]; then
            pref="system"
        elif [ "\$choice" = "2" ]; then
            pref="flatpak"
        else
            echo "Invalid choice"
            exit 1
        fi
    else
        pref="\$2"
    fi
    if [ "\$pref" = "system" ] || [ "\$pref" = "flatpak" ]; then
        echo "\$pref" > "\$PREF_FILE"
        echo "Preference set to \$pref"
    else
        echo "Invalid override: use 'system' or 'flatpak'"
    fi
    exit 0
elif [ "\$1" = "--fpwrapper-set-pre-script" ]; then
    if [ -z "\$2" ]; then
        echo "Usage: \$0 --fpwrapper-set-pre-script <script_path>"
        echo "Set a pre-launch script to run before the Flatpak app starts."
        exit 1
    fi
    if [ ! -f "\$2" ]; then
        echo "Script file not found: \$2"
        exit 1
    fi
    script_dir="\$PREF_DIR/scripts/\$NAME"
    mkdir -p "\$script_dir"
    cp "\$2" "\$script_dir/pre-launch.sh"
    chmod +x "\$script_dir/pre-launch.sh"
    echo "Pre-launch script set for \$NAME"
    exit 0
elif [ "\$1" = "--fpwrapper-set-post-script" ]; then
    if [ -z "\$2" ]; then
        echo "Usage: \$0 --fpwrapper-set-post-script <script_path>"
        echo "Set a post-run script to run after the Flatpak app exits."
        exit 1
    fi
    if [ ! -f "\$2" ]; then
        echo "Script file not found: \$2"
        exit 1
    fi
    script_dir="\$PREF_DIR/scripts/\$NAME"
    mkdir -p "\$script_dir"
    cp "\$2" "\$script_dir/post-run.sh"
    chmod +x "\$script_dir/post-run.sh"
    echo "Post-run script set for \$NAME"
    exit 0
elif [ "\$1" = "--fpwrapper-remove-pre-script" ]; then
    rm -f "\$PREF_DIR/scripts/\$NAME/pre-launch.sh"
    echo "Pre-launch script removed for \$NAME"
    exit 0
elif [ "\$1" = "--fpwrapper-remove-post-script" ]; then
    rm -f "\$PREF_DIR/scripts/\$NAME/post-run.sh"
    echo "Post-run script removed for \$NAME"
    exit 0
fi

# Function to execute pre-launch script
run_pre_launch_script() {
    PRE_LAUNCH_SCRIPT="\$PREF_DIR/scripts/\$NAME/pre-launch.sh"
    if [ -f "\$PRE_LAUNCH_SCRIPT" ] && [ -x "\$PRE_LAUNCH_SCRIPT" ]; then
        echo "Running pre-launch script for \$NAME..."
        "\$PRE_LAUNCH_SCRIPT" "\$NAME" "\$ID" "\$@" || {
            echo "Pre-launch script failed. Use --force to override."
            exit 1
        }
    fi
}

# Function to execute post-run script
run_post_run_script() {
    exit_code=\$1
    POST_RUN_SCRIPT="\$PREF_DIR/scripts/\$NAME/post-run.sh"
    if [ -f "\$POST_RUN_SCRIPT" ] && [ -x "\$POST_RUN_SCRIPT" ]; then
        echo "Running post-run script for \$NAME..."
        "\$POST_RUN_SCRIPT" "\$NAME" "\$ID" "\$exit_code" || true
    fi
}

# Function to load environment variables
load_env_vars() {
    ENV_FILE="\$PREF_DIR/\$NAME.env"
    if [ -f "\$ENV_FILE" ]; then
        # Source the env file to load variables
        source "\$ENV_FILE"
    fi
}

# Function to run command and handle post-run scripts
run_and_cleanup() {
    # Run the command and capture exit code
    "\$@"
    exit_code=\$?
    
    # Run post-run script if it exists
    run_post_run_script "\$exit_code"
    
    # Exit with same code as the command
    exit \$exit_code
}

# One-shot launch without persisting preference
if [ -n "$ONE_SHOT_PREF" ]; then
    run_single_launch "$ONE_SHOT_PREF" "$@"
fi

# Interactive execution logic (non-interactive already handled above)
if [ -f "\$PREF_FILE" ]; then
    PREF=\$(cat "\$PREF_FILE")
else
    PREF=""
fi

# Check for system command at launch time
SYSTEM_EXISTS=false
CMD_PATH=""

# Use command -v for secure path resolution
if command -v "\$NAME" >/dev/null 2>&1; then
    CMD_PATH=\$(command -v "\$NAME")
    # Verify it's not our own wrapper
    [ "\$CMD_PATH" != "\$SCRIPT_BIN_DIR/\$NAME" ] && SYSTEM_EXISTS=true
fi

if [ "\$PREF" = "system" ]; then
    if [ "\$SYSTEM_EXISTS" = true ]; then
        load_env_vars
        run_pre_launch_script "\$@"
        run_and_cleanup "\$NAME" "\$@"
    else
        # System command gone, fall back to flatpak
        # Atomic preference update to prevent race conditions
        temp_pref_file
        temp_pref_file=$(safe_mktemp "tmp.XXXXXX" "$(get_temp_dir 2>/dev/null || echo /tmp)")
        echo "flatpak" > "$temp_pref_file"
        mv "$temp_pref_file" "$PREF_FILE"
        
        load_env_vars
        run_pre_launch_script "$@"
        run_and_cleanup flatpak run "$ID" "$@"
    fi
elif [ "\$PREF" = "flatpak" ]; then
    load_env_vars
    run_pre_launch_script "\$@"
    run_and_cleanup flatpak run "\$ID" "\$@"
else
    # No pref set - interactive prompt (we know we're interactive here)
    if [ "\$SYSTEM_EXISTS" = true ]; then
        # Interactive CLI with system package available
        default_choice="system"
        choice_reason="system package available"
        
        echo "Multiple options for '\$NAME':"
        echo "1. System package (\$CMD_PATH)"
        echo "2. Flatpak app (\$ID)"
        echo ""
        read -r -p "Choose (1/2, default 1 - \$choice_reason): " choice
        choice=\${choice:-1}
        
        if [ "\$choice" = "1" ]; then
            PREF="system"
        elif [ "\$choice" = "2" ]; then
            PREF="flatpak"
        else
            echo "Invalid choice '\$choice', using default: \$default_choice"
            PREF="\$default_choice"
        fi
        
        # Atomic preference update
        temp_pref_file
temp_pref_file=$(safe_mktemp "tmp.XXXXXX" "$(get_temp_dir 2>/dev/null || echo /tmp)")
        if [ -z "$temp_pref_file" ]; then
            echo "Error: Failed to create temp file for preference update" >&2
            echo "Please check file permissions and disk space." >&2
            exit 1
        fi
        echo "$PREF" > "$temp_pref_file"
        mv "$temp_pref_file" "$PREF_FILE"
        
        load_env_vars
        run_pre_launch_script "\$@"
        
        if [ "\$PREF" = "system" ]; then
            run_and_cleanup "\$NAME" "\$@"
        else
            run_and_cleanup flatpak run "\$ID" "\$@"
        fi
    else
        # Only flatpak available
        PREF="flatpak"
        echo "\$PREF" > "\$PREF_FILE"
        load_env_vars
        run_pre_launch_script "\$@"
        run_and_cleanup flatpak run "\$ID" "\$@"
    fi
fi

# Check for system command at launch time
SYSTEM_EXISTS=false
CMD_PATH=""

# Use command -v for secure path resolution
if command -v "\$NAME" >/dev/null 2>&1; then
    CMD_PATH=\$(command -v "\$NAME")
    # Verify it's not our own wrapper
    [ "\$CMD_PATH" != "\$SCRIPT_BIN_DIR/\$NAME" ] && SYSTEM_EXISTS=true
fi

if [ "\$PREF" = "system" ]; then
    if [ "\$SYSTEM_EXISTS" = true ]; then
        load_env_vars
        run_pre_launch_script "\$@"
        run_and_cleanup "\$NAME" "\$@"
    else
        # System command gone, fall back to flatpak
        # Atomic preference update to prevent race conditions
        temp_pref_file
        temp_pref_file=$(safe_mktemp "tmp.XXXXXX" "$(get_temp_dir 2>/dev/null || echo /tmp)")
        echo "flatpak" > "$temp_pref_file"
        mv "$temp_pref_file" "$PREF_FILE"
        
        load_env_vars
        run_pre_launch_script "$@"
        run_and_cleanup flatpak run "$ID" "$@"
    fi
elif [ "\$PREF" = "flatpak" ]; then
    load_env_vars
    run_pre_launch_script "\$@"
    run_and_cleanup flatpak run "\$ID" "\$@"
else
    # No pref set - only show interactive prompt in interactive CLI
    if is_interactive && [ "$SYSTEM_EXISTS" = true ]; then
        # Interactive CLI with system package available
        default_choice="system"
        choice_reason="system package available"
        
        echo "Multiple options for '$NAME':"
        echo "1. System package ($CMD_PATH)"
        echo "2. Flatpak app ($ID)"
        echo ""
        read -r -p "Choose (1/2, default 1 - $choice_reason): " choice
        choice=${choice:-1}
        
        if [ "$choice" = "1" ]; then
            PREF="system"
        elif [ "$choice" = "2" ]; then
            PREF="flatpak"
        else
            echo "Invalid choice '$choice', using default: $default_choice"
            PREF="$default_choice"
        fi
        
        # Atomic preference update
        temp_pref_file
        temp_pref_file=$(safe_mktemp "tmp.XXXXXX" "$(get_temp_dir 2>/dev/null || echo /tmp)")
        if [ -z "$temp_pref_file" ]; then
            echo "Error: Failed to create temp file for preference update" >&2
            echo "Please check file permissions and disk space." >&2
            exit 1
        fi
        echo "$PREF" > "$temp_pref_file"
        mv "$temp_pref_file" "$PREF_FILE"
        
        load_env_vars
        run_pre_launch_script "$@"
            
if [ "$PREF" = "system" ]; then
        run_and_cleanup "$NAME" "$@"
    else
        run_and_cleanup flatpak run "$ID" "$@"
    fi
else
    # Non-interactive or only flatpak available
    if [ "$SYSTEM_EXISTS" = true ]; then
        # Non-interactive with system package - prefer system
        PREF="system"
        echo "$PREF" > "$PREF_FILE"
        load_env_vars
        run_pre_launch_script "$@"
        run_and_cleanup "$NAME" "$@"
    else
        # Only flatpak available
        PREF="flatpak"
        echo "$PREF" > "$PREF_FILE"
        load_env_vars
        run_pre_launch_script "$@"
        run_and_cleanup flatpak run "$ID" "$@"
    fi
fi
        else
            # Only flatpak available
            PREF="flatpak"
            echo "$PREF" > "$PREF_FILE"
            load_env_vars
            run_pre_launch_script "$@"
            run_and_cleanup flatpak run "$ID" "$@"
        fi
    else
        PREF="flatpak"
        echo "\$PREF" > "\$PREF_FILE"
        load_env_vars
        run_pre_launch_script "\$@"
        run_and_cleanup flatpak run "\$ID" "\$@"
    fi
fi
EOF
    chmod +x "$script_path"
    
    if [ "$wrapper_existed" = true ]; then
        echo "   ‚úÖ Updated wrapper: $name"
        updated_count=$((updated_count + 1))
    else
        echo "   ‚úÖ Created wrapper: $name"
        created_count=$((created_count + 1))
    fi
done < <(echo "$installed_ids")

# Report generation summary
echo ""
echo "üìä Generation Summary:"
echo "   ‚úÖ Created: $created_count new wrappers"
echo "   üîÑ Updated: $updated_count existing wrappers"
echo "   üö´ Blocked: $blocked_count applications"
echo "   ‚ö†Ô∏è  Skipped: $skipped_count applications"

# Report collision summary if any occurred
if [ ${#wrapper_collision_log[@]} -gt 0 ]; then
    echo ""
    echo "‚ö†Ô∏è  Name Collisions:"
    echo "   ${#wrapper_collision_log[@]} wrapper name(s) had collisions:"
    for name in "${!wrapper_collision_log[@]}"; do
        echo "     $name: Skipped apps${wrapper_collision_log[$name]}"
    done
    echo "   üí° Use 'fplaunch-manage set-alias' to create alternative names"
fi

# Clean up collision file
if [ -f "$COLLISION_FILE" ]; then
    rm -f "$COLLISION_FILE" 2>/dev/null || echo "Warning: Could not clean up collision file"
fi

echo ""
echo "üéâ Flatpak wrapper generation complete!"
echo ""
echo "üí° Next steps:"
echo "   fplaunch-manage list              # See your wrappers"
echo "   fplaunch-manage discover           # Discover features"
echo "   firefox --fpwrapper-help           # See wrapper options"